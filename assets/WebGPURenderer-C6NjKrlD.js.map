{"version":3,"file":"WebGPURenderer-C6NjKrlD.js","sources":["../../node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCubeTextureResource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","../../node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","../../node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = shader.gpuProgram;\n    this._shader = shader;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(\n        textureBatch.textures,\n        textureBatch.count,\n        renderer.limits.maxBatchableTextures\n      );\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState,\n      batch.topology\n    );\n    batch.bindGroup._touch(renderer.gc.now, renderer.tick);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GpuBatchAdaptor };\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getTextureView(texture);\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexport { BindGroupSystem };\n//# sourceMappingURL=BindGroupSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\n\"use strict\";\nclass GpuBufferData {\n  constructor(gpuBuffer) {\n    this.gpuBuffer = gpuBuffer;\n  }\n  destroy() {\n    this.gpuBuffer.destroy();\n    this.gpuBuffer = null;\n  }\n}\nclass GpuBufferSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._managedBuffers = new GCManagedHash({\n      renderer,\n      type: \"resource\",\n      onUnload: this.onBufferUnload.bind(this),\n      name: \"gpuBuffer\"\n    });\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    buffer._gcLastUsed = this._renderer.gc.now;\n    return buffer._gpuData[this._renderer.uid]?.gpuBuffer || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this.getGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    this._managedBuffers.removeAll();\n  }\n  onBufferUnload(buffer) {\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n  }\n  createGPUBuffer(buffer) {\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    buffer._resourceId = uid(\"resource\");\n    if (buffer.data) {\n      fastCopy(\n        buffer.data.buffer,\n        gpuBuffer.getMappedRange(),\n        buffer.data.byteOffset,\n        buffer.data.byteLength\n      );\n      gpuBuffer.unmap();\n    }\n    buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);\n    if (this._managedBuffers.add(buffer)) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n    }\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    this._managedBuffers.remove(buffer);\n    buffer._updateID = 0;\n    this.createGPUBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.destroy();\n    this._renderer = null;\n    this._gpu = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GpuBufferData, GpuBufferSystem };\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n","\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this.data = null;\n  }\n}\n\nexport { UboBatch };\n//# sourceMappingURL=UboBatch.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask) return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GpuColorMaskSystem };\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise) return this._initPromise;\n    this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexport { GpuDeviceSystem };\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline) return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer) return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer) return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup) return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.gc.now, this._renderer.tick);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount ?? geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1],\n      this._renderer.renderTarget.mipLevel,\n      this._renderer.renderTarget.layer\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexport { GpuEncoderSystem };\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuLimitsSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  contextChange() {\n    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n    this.maxBatchableTextures = this.maxTextures;\n  }\n  destroy() {\n  }\n}\n/** @ignore */\nGpuLimitsSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"limits\"\n};\n\nexport { GpuLimitsSystem };\n//# sourceMappingURL=GpuLimitsSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GpuStencilSystem };\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n","\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL };\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL.mjs';\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  const data = uboElement.data.type.indexOf(\"i32\") >= 0 ? \"dataInt32\" : \"data\";\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexport { generateArraySyncWGSL };\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL,\n    uboSyncFunctionsWGSL\n  );\n}\n\nexport { createUboSyncFunctionWGSL };\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL.mjs';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL.mjs';\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexport { GpuUboSystem };\n//# sourceMappingURL=GpuUboSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0) usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i]?.destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexport { GpuUniformBatchPipe };\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget, colorTargetCount) {\n  return colorMask << 8 | stencilStateId << 5 | renderTarget << 3 | colorTargetCount << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._colorTargetCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount) return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._colorTargetCount = renderTarget.colorTargetCount;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask) return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode) return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology || (topology = geometry.topology);\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key]) return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);\n    const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    for (let i = 0; i < blendModes.length; i++) {\n      blendModes[i].writeMask = writeMask;\n    }\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join(\"|\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join(\"|\");\n    program._attributeLocationsKey = createIdFromString(stringKey, \"programAttributes\");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      const attributes = Object.values(data[i].attributes);\n      const shaderLocation = attributes[0].shaderLocation;\n      for (const j in attributeData) {\n        if (attributeData[j].location === shaderLocation) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment,\n      this._colorTargetCount\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexport { PipelineSystem };\n//# sourceMappingURL=PipelineSystem.mjs.map\n","\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexport { GpuRenderTarget };\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n","import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport, mipLevel = 0, layer = 0) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (layer !== 0 && gpuRenderTarget.msaaTextures?.length) {\n      throw new Error(\"[RenderTargetSystem] Rendering to array layers is not supported with MSAA render targets.\");\n    }\n    if (mipLevel > 0 && gpuRenderTarget.msaaTextures?.length) {\n      throw new Error(\"[RenderTargetSystem] Rendering to mip levels is not supported with MSAA render targets.\");\n    }\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor, mipLevel, layer);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue, mipLevel = 0, layer = 0) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          if (layer !== 0) {\n            throw new Error(\"[RenderTargetSystem] Rendering to array layers is not supported for canvas targets.\");\n          }\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            // Render attachments must be 2d views; for array/cube textures we select a single layer.\n            dimension: \"2d\",\n            baseMipLevel: mipLevel,\n            mipLevelCount: 1,\n            baseArrayLayer: layer,\n            arrayLayerCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView({\n          dimension: \"2d\",\n          baseMipLevel: mipLevel,\n          mipLevelCount: 1,\n          baseArrayLayer: layer,\n          arrayLayerCount: 1\n        }),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport, mipLevel = 0, layer = 0) {\n    if (!clear) return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor, mipLevel, layer);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport, mipLevel, layer);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (colorTexture instanceof CanvasSource) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4,\n          arrayLayerCount: colorTexture.source.arrayLayerCount\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexport { GpuRenderTargetAdaptor };\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexport { GpuRenderTargetSystem };\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GpuShaderSystem };\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n","\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  }\n};\n\nexport { GpuBlendModesToPixi };\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi.mjs';\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   * @param count - The number of color targets to create\n   */\n  getColorTargets(state, count) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    const targets = [];\n    const target = {\n      format: \"bgra8unorm\",\n      writeMask: 0,\n      blend\n    };\n    for (let i = 0; i < count; i++) {\n      targets[i] = target;\n    }\n    return targets;\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexport { GpuStateSystem };\n//# sourceMappingURL=GpuStateSystem.mjs.map\n","\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu, originZOverride = 0) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture, origin: { x: 0, y: 0, z: originZOverride } },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelWidth * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexport { gpuUploadBufferImageResource };\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n","\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu, originZOverride = 0) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i,\n          origin: { x: 0, y: 0, z: originZOverride }\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { blockDataMap, gpuUploadCompressedTextureResource };\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n","\"use strict\";\nconst FACE_ORDER = [\"right\", \"left\", \"top\", \"bottom\", \"front\", \"back\"];\nfunction createGpuUploadCubeTextureResource(uploaders) {\n  return {\n    type: \"cube\",\n    upload(source, gpuTexture, gpu) {\n      const faces = source.faces;\n      for (let i = 0; i < FACE_ORDER.length; i++) {\n        const key = FACE_ORDER[i];\n        const face = faces[key];\n        const uploader = uploaders[face.uploadMethodId] || uploaders.image;\n        uploader.upload(face, gpuTexture, gpu, i);\n      }\n    }\n  };\n}\n\nexport { createGpuUploadCubeTextureResource };\n//# sourceMappingURL=gpuUploadCubeTextureResource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu, originZOverride = 0) {\n    const resource = source.resource;\n    if (!resource) return;\n    if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {\n      const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(resource, 0, 0, resource.width, resource.height);\n      source.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas and replacing resource.\");\n    }\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, origin: { x: 0, y: 0, z: originZOverride }, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexport { gpuUploadImageResource };\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n","import { gpuUploadImageResource } from './gpuUploadImageSource.mjs';\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu, originZOverride) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu, originZOverride);\n  }\n};\n\nexport { gpuUploadVideoResource };\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n","\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexport { GpuMipmapGenerator };\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { createGpuUploadCubeTextureResource } from './uploaders/gpuUploadCubeTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\n\"use strict\";\nclass GPUTextureGpuData {\n  constructor(gpuTexture) {\n    this.textureView = null;\n    this.gpuTexture = gpuTexture;\n  }\n  /** Destroys this GPU data instance. */\n  destroy() {\n    this.gpuTexture.destroy();\n    this.textureView = null;\n    this.gpuTexture = null;\n  }\n}\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.gc.addCollection(this, \"_bindGroupHash\", \"hash\");\n    this._managedTextures = new GCManagedHash({\n      renderer,\n      type: \"resource\",\n      onUnload: this.onSourceUnload.bind(this),\n      name: \"gpuTextureSource\"\n    });\n    const baseUploaders = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._uploads = {\n      ...baseUploaders,\n      cube: createGpuUploadCubeTextureResource(baseUploaders)\n    };\n  }\n  /**\n   * @deprecated since 8.15.0\n   */\n  get managedTextures() {\n    return Object.values(this._managedTextures.items);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  /**\n   * Initializes a texture source, if it has already been initialized nothing will happen.\n   * @param source - The texture source to initialize.\n   * @returns The initialized texture source.\n   */\n  initSource(source) {\n    return source._gpuData[this._renderer.uid]?.gpuTexture || this._initSource(source);\n  }\n  _initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height, depthOrArrayLayers: source.arrayLayerCount },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);\n    const added = this._managedTextures.add(source);\n    if (added) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture) return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceUnload(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n  }\n  onSourceResize(source) {\n    source._gcLastUsed = this._renderer.gc.now;\n    const gpuData = source._gpuData[this._renderer.uid];\n    const gpuTexture = gpuData?.gpuTexture;\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      gpuData.destroy();\n      this._bindGroupHash[source.uid] = null;\n      source._gpuData[this._renderer.uid] = null;\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    source._gcLastUsed = this._renderer.gc.now;\n    return source._gpuData[this._renderer.uid]?.gpuTexture || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup({\n      0: source,\n      1: source.style,\n      2: new UniformGroup({\n        uTextureMatrix: { type: \"mat3x3<f32>\", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    source._gcLastUsed = this._renderer.gc.now;\n    let gpuData = source._gpuData[this._renderer.uid];\n    if (!gpuData) {\n      this.initSource(source);\n      gpuData = source._gpuData[this._renderer.uid];\n    }\n    gpuData.textureView || (gpuData.textureView = gpuData.gpuTexture.createView({ dimension: source.viewDimension }));\n    return gpuData.textureView;\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this._managedTextures.destroy();\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n    }\n    this._renderer = null;\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSamplers = null;\n    this._bindGroupHash = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GPUTextureGpuData, GpuTextureSystem };\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  constructor() {\n    this._maxTextures = 0;\n  }\n  contextChange(renderer) {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this._maxTextures = renderer.limits.maxBatchableTextures;\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(this._maxTextures),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(\n          batcher.geometry,\n          shader.gpuProgram,\n          graphicsPipe.state,\n          batch.topology\n        );\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(\n          textureBatch.textures,\n          textureBatch.count,\n          this._maxTextures\n        );\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit,\n        textureBit,\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.EMPTY._source,\n        uSampler: Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GpuMeshAdapter };\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter.mjs';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { BindGroupSystem } from './BindGroupSystem.mjs';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem.mjs';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem.mjs';\nimport { GpuDeviceSystem } from './GpuDeviceSystem.mjs';\nimport { GpuEncoderSystem } from './GpuEncoderSystem.mjs';\nimport { GpuLimitsSystem } from './GpuLimitsSystem.mjs';\nimport { GpuStencilSystem } from './GpuStencilSystem.mjs';\nimport { GpuUboSystem } from './GpuUboSystem.mjs';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe.mjs';\nimport { PipelineSystem } from './pipeline/PipelineSystem.mjs';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem.mjs';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem.mjs';\nimport { GpuStateSystem } from './state/GpuStateSystem.mjs';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuLimitsSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGPURenderer };\n//# sourceMappingURL=WebGPURenderer.mjs.map\n"],"names":["tempState","State","GpuBatchAdaptor","batchPipe","geometry","shader","renderer","encoder","program","globalUniformsBindGroup","batch","textureBatch","getTextureBatchBindGroup","gpuBindGroup","pipeline","ExtensionType","BindGroupSystem","gpu","bindGroup","groupIndex","group","device","groupLayout","entries","j","resource","gpuResource","uniformGroup","buffer","bufferResource","sampler","texture","layout","GpuBufferData","gpuBuffer","GpuBufferSystem","GCManagedHash","data","uid","fastCopy","UboBatch","minUniformOffsetAlignment","size","start","newSize","array","offset","i","GpuColorMaskSystem","colorMask","GpuDeviceSystem","options","adapter","DOMAdapter","requiredFeatures","feature","GpuEncoderSystem","resolve","gpuRenderTarget","viewport","state","topology","index","indexFormat","buffersToBind","skipSync","instanceCount","descriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","GpuLimitsSystem","GpuStencilSystem","renderTarget","stencilState","STENCIL_MODES","stencilMode","stencilReference","WGSL_ALIGN_SIZE_DATA","createUboElementsWGSL","uniformData","uboElements","uboElement","align","generateArraySyncWGSL","offsetToAdd","remainder","createUboSyncFunctionWGSL","createUboSyncFunction","uboSyncFunctionsWGSL","GpuUboSystem","UboSystem","GpuUniformBatchPipe","totalBuffers","usage","BufferUsage","Buffer","duplicate","BufferResource","BindGroup","bufferSystem","firstBuffer","commandEncoder","topologyStringToId","getGraphicsStateKey","geometryLayout","shaderKey","blendMode","getGlobalStateKey","stencilStateId","multiSampleCount","colorTargetCount","PipelineSystem","multisampleCount","GpuStencilModesToPixi","passEncoder","ensureAttributes","key","buffers","blendModes","writeMask","code","keyGen","attributeKeys","attribute","stringKey","createIdFromString","bufferNamesToBind","attributeData","shaderLocation","vertexBuffersLayout","bufferEntry","bufferEntryAttributes","warn","GpuRenderTarget","GpuRenderTargetAdaptor","renderTargetSystem","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","backGpuTexture","clear","clearColor","mipLevel","layer","clearValue","CLEAR","colorAttachments","context","view","resolveTarget","loadOp","depthStencilAttachment","stencilLoadOp","depthLoadOp","renderPassDescriptor","gpuCommands","colorTexture","CanvasSource","alphaMode","e","msaaTexture","TextureSource","GpuRenderTargetSystem","RenderTargetSystem","GpuShaderSystem","bindGroups","pipelineLayoutDesc","GpuBlendModesToPixi","GpuStateSystem","count","blend","targets","target","gpuUploadBufferImageResource","source","gpuTexture","originZOverride","total","bytesPerPixel","blockDataMap","defaultBlockData","gpuUploadCompressedTextureResource","mipWidth","mipHeight","blockData","levelBuffer","bytesPerRow","FACE_ORDER","createGpuUploadCubeTextureResource","uploaders","faces","face","gpuUploadImageResource","canvas","width","height","premultipliedAlpha","gpuUploadVideoResource","GpuMipmapGenerator","format","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","bindGroupLayout","arrayLayer","srcView","dstMipLevel","dstView","mipLevelSize","GPUTextureGpuData","GpuTextureSystem","baseUploaders","biggestDimension","textureDescriptor","gpuData","UniformGroup","webGPUCanvas","canvasAndContext","CanvasPool","imageData","pixels","k","GpuGraphicsAdaptor","localUniforms","Matrix","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","localUniformBitGroup2","roundPixelsBit","Shader","graphicsPipe","renderable","contextSystem","batcher","instructions","localBindGroup","batches","GpuMeshAdapter","localUniformBit","textureBit","Texture","meshPipe","mesh","DefaultWebGPUSystems","SharedSystems","DefaultWebGPUPipes","SharedRenderPipes","DefaultWebGPUAdapters","systems","renderPipes","renderPipeAdaptors","extensions","WebGPURenderer","AbstractRenderer","systemConfig","RendererType"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}