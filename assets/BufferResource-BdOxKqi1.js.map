{"version":3,"file":"BufferResource-BdOxKqi1.js","sources":["../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"],"sourcesContent":["\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n"],"names":["localUniformBit","localUniformBitGroup2","localUniformBitGl","textureBit","textureBitGl","ensureAttributes","geometry","extractedData","i","attribute","attributeData","warn","ensureStartAndStride","buffers","attributes","tempStride","tempStart","j","buffer","getAttributeInfoFromFormat","GpuStencilModesToPixi","STENCIL_MODES","UboSystem","adaptor","unsafeEvalSupported","uniformGroup","uniformData","Buffer","BufferUsage","uniformGroupSignature","elements","layout","syncFunction","uboElements","data","offset","uniformGroupData","dataInt32","synced","uniformParsers","createUboSyncFunction","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","name","parsed","template","fragmentSrc","loopMatrix","col","row","uboSyncFunctionsSTD40","uboSyncFunctionsWGSL","BufferResource","EventEmitter","size","uid","destroyBuffer"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}