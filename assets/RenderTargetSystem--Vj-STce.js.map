{"version":3,"file":"RenderTargetSystem--Vj-STce.js","sources":["../../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","../../node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","../../node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","../../node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","../../node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","../../node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","../../node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","../../node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","../../node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","../../node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","../../node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","../../node_modules/pixi.js/lib/utils/data/clean.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/GCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","../../node_modules/pixi.js/lib/utils/sayHello.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"],"sourcesContent":["var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      clipToViewport: false,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher({\n        maxTextures: this.renderer.limits.maxBatchableTextures\n      }));\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const gpuRenderer = renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      gpuRenderer.renderTarget.ensureDepthStencil();\n      gpuRenderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      gpuRenderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      gpuRenderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      gpuRenderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        gpuRenderer.renderTarget.clear(null, CLEAR.STENCIL);\n        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      gpuRenderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable) return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable) return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = new Matrix().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295,\n        offset: { x: 0, y: 0 }\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._blendModeStack = [];\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = \"normal\";\n    this._isAdvanced = false;\n  }\n  /**\n   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n   * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n   * @param blendMode - The blend mode to activate.\n   * @param instructionSet - The instruction set being built.\n   */\n  pushBlendMode(renderable, blendMode, instructionSet) {\n    this._blendModeStack.push(blendMode);\n    this.setBlendMode(renderable, blendMode, instructionSet);\n  }\n  /**\n   * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  popBlendMode(instructionSet) {\n    this._blendModeStack.pop();\n    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? \"normal\";\n    this.setBlendMode(null, blendMode, instructionSet);\n  }\n  /**\n   * Ensure a blend mode switch is added to the instruction set when the mode changes.\n   * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n   * rendered within a single filter pass.\n   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n   * @param blendMode - The target blend mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    const isRenderGroup = renderable instanceof RenderGroup;\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced && renderable && !isRenderGroup) {\n        this._renderableList?.push(renderable);\n      }\n      return;\n    }\n    if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n    this._activeBlendMode = blendMode;\n    if (!renderable) return;\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n  }\n  _beginAdvancedBlendMode(renderable, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    const filterEffect = this._ensureFilterEffect(blendMode);\n    const isRenderGroup = renderable instanceof RenderGroup;\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      filterEffect,\n      renderables: isRenderGroup ? null : [renderable],\n      container: isRenderGroup ? renderable.root : null,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _ensureFilterEffect(blendMode) {\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    return filterEffect;\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._isAdvanced = false;\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   */\n  buildEnd(instructionSet) {\n    if (!this._isAdvanced) return;\n    this._endAdvancedBlendMode(instructionSet);\n  }\n  /** @internal */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { multiplyColors } from './multiplyColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick) return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.textureNeedsUpdate) return;\n      closestCacheAsTexture = renderGroup;\n    }\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        const scaleMode = renderGroup.textureOptions.scaleMode ?? \"linear\";\n        const lastTexture = renderGroup.texture;\n        bounds.ceil();\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture, true);\n        }\n        const texture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        texture._source.style = new TextureStyle({ scaleMode });\n        renderGroup.texture = texture;\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture, true);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    const incoming = Color.shared.setValue(value);\n    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {\n      warn(\n        \"Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.\"\n      );\n    }\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Creates an IImage from a display object or texture.\n   * @param options - Options for creating the image, or the target to extract\n   * @returns Promise that resolves with the generated IImage\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const image = await renderer.extract.image(sprite);\n   * document.body.appendChild(image);\n   *\n   * // Advanced usage with options\n   * const image = await renderer.extract.image({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2,\n   *     clearColor: '#ff0000',\n   *     antialias: true\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const image = await renderer.extract.image(texture);\n   * ```\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.base64} For base64 string output\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ImageLike} For the image interface\n   * @category rendering\n   */\n  async image(options) {\n    const image = DOMAdapter.get().createImage();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Converts the target into a base64 encoded string.\n   *\n   * This method works by first creating\n   * a canvas using `Extract.canvas` and then converting it to a base64 string.\n   * @param options - The options for creating the base64 string, or the target to extract\n   * @returns Promise that resolves with the base64 encoded string\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const base64 = await renderer.extract.base64(sprite);\n   * console.log(base64); // data:image/png;base64,...\n   *\n   * // Advanced usage with options\n   * const base64 = await renderer.extract.base64({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2\n   * });\n   * ```\n   * @throws Will throw an error if the platform doesn't support any of:\n   * - ICanvas.toDataURL\n   * - ICanvas.toBlob\n   * - ICanvas.convertToBlob\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @category rendering\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders the target to it and returns it.\n   * This method is useful for creating static images or when you need direct canvas access.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns A Canvas element with the texture rendered on\n   * @example\n   * ```ts\n   * // Basic canvas extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const canvas = renderer.extract.canvas(sprite);\n   * document.body.appendChild(canvas);\n   *\n   * // Extract with custom region\n   * const canvas = renderer.extract.canvas({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const canvas = renderer.extract.canvas({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const canvas = renderer.extract.canvas(texture);\n   *\n   * // Extract with anti-aliasing\n   * const canvas = renderer.extract.canvas({\n   *     target: graphics,\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n   * with integer values between 0 and 255 (inclusive).\n   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n   * @example\n   * ```ts\n   * // Basic pixel extraction\n   * const sprite = new Sprite(texture);\n   * const pixels = renderer.extract.pixels(sprite);\n   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n   *\n   * // Extract with custom region\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     resolution: 2\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For image output\n   * @category rendering\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Creates a texture from a display object or existing texture.\n   *\n   * This is useful for creating\n   * reusable textures from rendered content or making copies of existing textures.\n   * > [!NOTE] The returned texture should be destroyed when no longer needed\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns A new texture containing the extracted content\n   * @example\n   * ```ts\n   * // Basic texture extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const extractedTexture = renderer.extract.texture(sprite);\n   *\n   * // Extract with custom region\n   * const regionTexture = renderer.extract.texture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const hiResTexture = renderer.extract.texture({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Create a new sprite from extracted texture\n   * const newSprite = new Sprite(\n   *     renderer.extract.texture({\n   *         target: graphics,\n   *         antialias: true\n   *     })\n   * );\n   *\n   * // Clean up when done\n   * extractedTexture.destroy(true);\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link Texture} For texture management\n   * @see {@link GenerateTextureSystem} For texture generation\n   * @category rendering\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture) return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Extracts and downloads content from the renderer as an image file.\n   * This is a convenient way to save screenshots or export rendered content.\n   * > [!NOTE] The download will use PNG format regardless of the filename extension\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   * @example\n   * ```ts\n   * // Basic download with default filename\n   * const sprite = new Sprite(texture);\n   * renderer.extract.download(sprite); // Downloads as 'image.png'\n   *\n   * // Download with custom filename\n   * renderer.extract.download({\n   *     target: sprite,\n   *     filename: 'screenshot.png'\n   * });\n   *\n   * // Download with custom region\n   * renderer.extract.download({\n   *     target: container,\n   *     filename: 'region.png',\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Download with high resolution and background\n   * renderer.extract.download({\n   *     target: stage,\n   *     filename: 'hd-screenshot.png',\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Download with anti-aliasing\n   * renderer.extract.download({\n   *     target: graphics,\n   *     filename: 'smooth.png',\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractDownloadOptions} For detailed options\n   * @see {@link ExtractSystem.image} For creating images without download\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * The image will be displayed in the browser's console using CSS background images.\n   * @param options - The options for logging the image, or the target to log\n   * @param options.width - The width of the logged image preview in the console (in pixels)\n   * @example\n   * ```ts\n   * // Basic usage\n   * const sprite = new Sprite(texture);\n   * renderer.extract.log(sprite);\n   * ```\n   * @see {@link ExtractSystem.canvas} For getting raw canvas output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   * @advanced\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"extract\"\n};\n/**\n * Default options for image extraction.\n * @example\n * ```ts\n * // Customize default options\n * ExtractSystem.defaultImageOptions.format = 'webp';\n * ExtractSystem.defaultImageOptions.quality = 0.8;\n *\n * // Use defaults\n * const image = await renderer.extract.image(sprite);\n * ```\n */\n_ExtractSystem.defaultImageOptions = {\n  format: \"png\",\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  /**\n   * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n   * @param options - Options for the RenderTexture, including width, height, and dynamic.\n   * @returns A new RenderTexture instance.\n   * @example\n   * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n   * rt.resize(500, 500);\n   */\n  static create(options) {\n    const { dynamic, ...rest } = options;\n    return new RenderTexture({\n      source: new TextureSource(rest),\n      dynamic: dynamic ?? false\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Creates a texture from a display object that can be used for creating sprites and other textures.\n   * This is particularly useful for optimizing performance when a complex container needs to be reused.\n   * @param options - Generate texture options or a container to convert to texture\n   * @returns A new RenderTexture containing the rendered display object\n   * @example\n   * ```ts\n   * // Basic usage with a container\n   * const container = new Container();\n   * container.addChild(\n   *     new Graphics()\n   *         .circle(0, 0, 50)\n   *         .fill('red')\n   * );\n   *\n   * const texture = renderer.textureGenerator.generateTexture(container);\n   *\n   * // Advanced usage with options\n   * const texture = renderer.textureGenerator.generateTexture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n   *     resolution: 2,                        // High DPI\n   *     clearColor: '#ff0000',               // Red background\n   *     antialias: true                      // Smooth edges\n   * });\n   *\n   * // Create a sprite from the generated texture\n   * const sprite = new Sprite(texture);\n   *\n   * // Clean up when done\n   * texture.destroy(true);\n   * ```\n   * @see {@link GenerateTextureOptions} For detailed texture generation options\n   * @see {@link RenderTexture} For the type of texture created\n   * @category rendering\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean) return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../utils/data/clean.mjs';\n\n\"use strict\";\nconst _GCSystem = class _GCSystem {\n  /**\n   * Creates a new GCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of resources being tracked for garbage collection */\n    this._managedResources = [];\n    this._managedResourceHashes = [];\n    this._managedCollections = [];\n    this._ready = false;\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options\n   */\n  init(options) {\n    options = { ..._GCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.gcMaxUnusedTime;\n    this._frequency = options.gcFrequency;\n    this.enabled = options.gcActive;\n    this.now = performance.now();\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value) return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => {\n          this._ready = true;\n        },\n        this._frequency,\n        false\n      );\n      this._collectionsHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedCollections) {\n            const { context, collection, type } = hash;\n            if (type === \"hash\") {\n              context[collection] = cleanHash(context[collection]);\n            } else {\n              context[collection] = cleanArray(context[collection]);\n            }\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._collectionsHandler);\n      this._handler = 0;\n      this._collectionsHandler = 0;\n    }\n  }\n  /**\n   * Called before rendering. Updates the current timestamp.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({ container }) {\n    this.now = performance.now();\n    container.renderGroup.gcTick = this._renderer.tick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /** Performs garbage collection after rendering. */\n  postrender() {\n    if (!this._ready || !this.enabled) return;\n    this.run();\n    this._ready = false;\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    renderGroup.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n  /**\n   * Registers a collection for garbage collection tracking.\n   * @param context - The object containing the collection\n   * @param collection - The property name on context that holds the collection\n   * @param type - The type of collection to track ('hash' or 'array')\n   */\n  addCollection(context, collection, type) {\n    this._managedCollections.push({\n      context,\n      collection,\n      type\n    });\n  }\n  /**\n   * Registers a resource for garbage collection tracking.\n   * @param resource - The resource to track\n   * @param type - The type of resource to track\n   */\n  addResource(resource, type) {\n    if (resource._gcLastUsed !== -1) {\n      resource._gcLastUsed = this.now;\n      resource._onTouch?.(this.now);\n      return;\n    }\n    const index = this._managedResources.length;\n    resource._gcData = {\n      index,\n      type\n    };\n    resource._gcLastUsed = this.now;\n    resource._onTouch?.(this.now);\n    resource.once(\"unload\", this.removeResource, this);\n    this._managedResources.push(resource);\n  }\n  /**\n   * Removes a resource from garbage collection tracking.\n   * Call this when manually destroying a resource.\n   * @param resource - The resource to stop tracking\n   */\n  removeResource(resource) {\n    const gcData = resource._gcData;\n    if (!gcData) return;\n    const index = gcData.index;\n    const last = this._managedResources.length - 1;\n    if (index !== last) {\n      const lastResource = this._managedResources[last];\n      this._managedResources[index] = lastResource;\n      lastResource._gcData.index = index;\n    }\n    this._managedResources.length--;\n    resource._gcData = null;\n    resource._gcLastUsed = -1;\n  }\n  /**\n   * Registers a hash-based resource collection for garbage collection tracking.\n   * Resources in the hash will be automatically tracked and cleaned up when unused.\n   * @param context - The object containing the hash property\n   * @param hash - The property name on context that holds the resource hash\n   * @param type - The type of resources in the hash ('resource' or 'renderable')\n   * @param priority - Processing priority (lower values are processed first)\n   */\n  addResourceHash(context, hash, type, priority = 0) {\n    this._managedResourceHashes.push({\n      context,\n      hash,\n      type,\n      priority\n    });\n    this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Performs garbage collection by cleaning up unused resources.\n   * Removes resources that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = performance.now();\n    const managedResourceHashes = this._managedResourceHashes;\n    for (const hashEntry of managedResourceHashes) {\n      this.runOnHash(hashEntry, now);\n    }\n    let writeIndex = 0;\n    for (let i = 0; i < this._managedResources.length; i++) {\n      const resource = this._managedResources[i];\n      writeIndex = this.runOnResource(resource, now, writeIndex);\n    }\n    this._managedResources.length = writeIndex;\n  }\n  updateRenderableGCTick(renderable, now) {\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n    if ((renderGroup?.gcTick ?? 0) === currentTick) {\n      renderable._gcLastUsed = now;\n      renderable._onTouch?.(now);\n    }\n  }\n  runOnResource(resource, now, writeIndex) {\n    const gcData = resource._gcData;\n    if (gcData.type === \"renderable\") {\n      this.updateRenderableGCTick(resource, now);\n    }\n    const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n    if (isRecentlyUsed || !resource.autoGarbageCollect) {\n      this._managedResources[writeIndex] = resource;\n      gcData.index = writeIndex;\n      writeIndex++;\n    } else {\n      resource.unload();\n      resource._gcData = null;\n      resource._gcLastUsed = -1;\n      resource.off(\"unload\", this.removeResource, this);\n    }\n    return writeIndex;\n  }\n  /**\n   * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n   * @param hashValue - The original hash to clone from\n   * @param stopKey - The key to stop at (exclusive)\n   * @returns A new hash object with copied entries\n   */\n  _createHashClone(hashValue, stopKey) {\n    const hashClone = /* @__PURE__ */ Object.create(null);\n    for (const k in hashValue) {\n      if (k === stopKey) break;\n      if (hashValue[k] !== null) hashClone[k] = hashValue[k];\n    }\n    return hashClone;\n  }\n  runOnHash(hashEntry, now) {\n    const { context, hash, type } = hashEntry;\n    const hashValue = context[hash];\n    let hashClone = null;\n    let nullCount = 0;\n    for (const key in hashValue) {\n      const resource = hashValue[key];\n      if (resource === null) {\n        nullCount++;\n        if (nullCount === 1e4 && !hashClone) {\n          hashClone = this._createHashClone(hashValue, key);\n        }\n        continue;\n      }\n      if (resource._gcLastUsed === -1) {\n        resource._gcLastUsed = now;\n        resource._onTouch?.(now);\n        if (hashClone) hashClone[key] = resource;\n        continue;\n      }\n      if (type === \"renderable\") {\n        this.updateRenderableGCTick(resource, now);\n      }\n      const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n      if (!isRecentlyUsed && resource.autoGarbageCollect) {\n        if (!hashClone) {\n          if (nullCount + 1 !== 1e4) {\n            hashValue[key] = null;\n            nullCount++;\n          } else {\n            hashClone = this._createHashClone(hashValue, key);\n          }\n        }\n        if (type === \"renderable\") {\n          const res = resource;\n          const renderGroup = res.renderGroup ?? res.parentRenderGroup;\n          if (renderGroup) renderGroup.structureDidChange = true;\n        }\n        resource.unload();\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n      } else if (hashClone) {\n        hashClone[key] = resource;\n      }\n    }\n    if (hashClone) {\n      context[hash] = hashClone;\n    }\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._managedResources.forEach((resource) => {\n      resource.off(\"unload\", this.removeResource, this);\n    });\n    this._managedResources.length = 0;\n    this._managedResourceHashes.length = 0;\n    this._managedCollections.length = 0;\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_GCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"gc\",\n  priority: 0\n};\n/** Default options for the GCSystem */\n_GCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  gcActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  gcMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  gcFrequency: 3e4\n};\nlet GCSystem = _GCSystem;\n\nexport { GCSystem };\n//# sourceMappingURL=GCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n    this._globalUniformDataStack.length = 0;\n    this._uniformsPool.length = 0;\n    this._activeUniforms.length = 0;\n    this._bindGroupPool.length = 0;\n    this._activeBindGroups.length = 0;\n    this._currentGlobalUniformData = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { deprecation } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    deprecation(\"8.15.0\", \"RenderableGCSystem.enabled is deprecated, please use the GCSystem.enabled instead.\");\n    return this._renderer.gc.enabled;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    deprecation(\"8.15.0\", \"RenderableGCSystem.enabled is deprecated, please use the GCSystem.enabled instead.\");\n    this._renderer.gc.enabled = value;\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    deprecation(\"8.15.0\", \"RenderableGCSystem.addManagedHash is deprecated, please use the GCSystem.addCollection instead.\");\n    this._renderer.gc.addCollection(context, hash, \"hash\");\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    deprecation(\"8.15.0\", \"RenderableGCSystem.addManagedArray is deprecated, please use the GCSystem.addCollection instead.\");\n    this._renderer.gc.addCollection(context, hash, \"array\");\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param _renderable - The renderable to track\n   * @deprecated since 8.15.0\n   */\n  addRenderable(_renderable) {\n    deprecation(\"8.15.0\", \"RenderableGCSystem.addRenderable is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.addResource(_renderable, \"renderable\");\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    deprecation(\"8.15.0\", \"RenderableGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.run();\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this._renderer = null;\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n * @deprecated since 8.15.0\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { deprecation } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /**\n   * Frame count since started.\n   * @readonly\n   * @deprecated since 8.15.0\n   */\n  get count() {\n    return this._renderer.tick;\n  }\n  /**\n   * Frame count since last garbage collection.\n   * @readonly\n   * @deprecated since 8.15.0\n   */\n  get checkCount() {\n    return this._checkCount;\n  }\n  set checkCount(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._checkCount = value;\n  }\n  /**\n   * Maximum idle frames before a texture is destroyed by garbage collection.\n   * @see TextureGCSystem.defaultMaxIdle\n   * @deprecated since 8.15.0\n   */\n  get maxIdle() {\n    return this._renderer.gc.maxUnusedTime / 1e3 * 60;\n  }\n  set maxIdle(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.maxUnusedTime = value / 60 * 1e3;\n  }\n  /**\n   * Frames between two garbage collections.\n   * @see TextureGCSystem.defaultCheckCountMax\n   * @deprecated since 8.15.0\n   */\n  // eslint-disable-next-line dot-notation\n  get checkCountMax() {\n    return Math.floor(this._renderer.gc[\"_frequency\"] / 1e3);\n  }\n  set checkCountMax(_value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n  }\n  /**\n   * Current garbage collection mode.\n   * @see TextureGCSystem.defaultMode\n   * @deprecated since 8.15.0\n   */\n  get active() {\n    return this._renderer.gc.enabled;\n  }\n  set active(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.enabled = value;\n  }\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._checkCount = 0;\n  }\n  init(options) {\n    if (options.textureGCActive !== _TextureGCSystem.defaultOptions.textureGCActive) {\n      this.active = options.textureGCActive;\n    }\n    if (options.textureGCMaxIdle !== _TextureGCSystem.defaultOptions.textureGCMaxIdle) {\n      this.maxIdle = options.textureGCMaxIdle;\n    }\n    if (options.textureGCCheckCountMax !== _TextureGCSystem.defaultOptions.textureGCCheckCountMax) {\n      this.checkCountMax = options.textureGCCheckCountMax;\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   * @deprecated since 8.15.0\n   */\n  run() {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.run();\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/**\n * Default options for the TextureGCSystem\n * @deprecated since 8.15.0\n */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0) return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry.mjs';\nimport { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nGlobalResourceRegistry.register(canvasCache);\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n   * @type {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @example\n   * viewSystem.destroy();\n   * viewSystem.destroy(true);\n   * viewSystem.destroy({ removeView: true });\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n    this.texture.destroy();\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GCSystem } from '../GCSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  GCSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass */\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /** the current mip level being rendered to (for texture subresources) */\n    this.mipLevel = 0;\n    /** the current array layer being rendered to (for array-backed targets) */\n    this.layer = 0;\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.gc.addCollection(this, \"_gpuRenderTargetHash\", \"hash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   * @param options.mipLevel - the mip level to render to\n   * @param options.layer - The layer of the render target to render to. Used for array or 3D textures, or when rendering\n   * to a specific layer of a layered render target. Optional.\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame,\n    mipLevel,\n    layer\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame,\n      mipLevel ?? 0,\n      layer ?? 0\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provided and the render surface is a {@link Texture}, the frame of the texture will be used.\n   *\n   * IMPORTANT:\n   * - `frame` is treated as **base mip (mip 0) pixel space**.\n   * - When `mipLevel > 0`, the viewport derived from `frame` is scaled by \\(2^{mipLevel}\\) and clamped to the\n   *   mip dimensions. This keeps \"render the same region\" semantics consistent across mip levels.\n   * - When `renderSurface` is a {@link Texture}, `renderer.render({ container, target: texture, mipLevel })` will\n   *   render into\n   *   the underlying {@link TextureSource} (Pixi will create/use a {@link RenderTarget} for the source) using the\n   *   texture's frame to define the region (in mip 0 space).\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @param mipLevel - the mip level to render to\n   * @param layer - the layer (or slice) of the render surface to render to. For array textures,\n   * 3D textures, or cubemaps, this specifies the target layer or face. Defaults to 0 (the first layer/face).\n   * Ignored for surfaces that do not support layers.\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame, mipLevel = 0, layer = 0) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const arrayLayerCount = source.arrayLayerCount || 1;\n    if ((layer | 0) !== layer) {\n      layer |= 0;\n    }\n    if (layer < 0 || layer >= arrayLayerCount) {\n      throw new Error(`[RenderTargetSystem] layer ${layer} is out of bounds (arrayLayerCount=${arrayLayerCount}).`);\n    }\n    this.mipLevel = mipLevel | 0;\n    this.layer = layer | 0;\n    const pixelWidth = Math.max(source.pixelWidth >> mipLevel, 1);\n    const pixelHeight = Math.max(source.pixelHeight >> mipLevel, 1);\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      const scale = 1 << Math.max(mipLevel | 0, 0);\n      const baseX = frame.x * resolution + 0.5 | 0;\n      const baseY = frame.y * resolution + 0.5 | 0;\n      const baseW = frame.width * resolution + 0.5 | 0;\n      const baseH = frame.height * resolution + 0.5 | 0;\n      let x = Math.floor(baseX / scale);\n      let y = Math.floor(baseY / scale);\n      let w = Math.ceil(baseW / scale);\n      let h = Math.ceil(baseH / scale);\n      x = Math.min(Math.max(x, 0), pixelWidth - 1);\n      y = Math.min(Math.max(y, 0), pixelHeight - 1);\n      w = Math.min(Math.max(w, 1), pixelWidth - x);\n      h = Math.min(Math.max(h, 1), pixelHeight - y);\n      viewport.x = x;\n      viewport.y = y;\n      viewport.width = w;\n      viewport.height = h;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport, mipLevel, layer);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor, mipLevel = this.mipLevel, layer = this.layer) {\n    if (!clear) return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport,\n      mipLevel,\n      layer\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   * @param mipLevel - the mip level to render to\n   * @param layer - The layer of the render surface to render to. For array textures or cube maps, this specifies\n   * which layer or face to target. Defaults to 0 (the first layer).\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame, mipLevel = 0, layer = 0) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame, mipLevel, layer);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame,\n      mipLevel,\n      layer\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(\n      currentRenderTargetData.renderTarget,\n      false,\n      null,\n      currentRenderTargetData.frame,\n      currentRenderTargetData.mipLevel,\n      currentRenderTargetData.layer\n    );\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param {Texture} destinationTexture - the texture to copy to\n   * @param {object} originSrc - the origin of the copy\n   * @param {number} originSrc.x - the x origin of the copy\n   * @param {number} originSrc.y - the y origin of the copy\n   * @param {object} size - the size of the copy\n   * @param {number} size.width - the width of the copy\n   * @param {number} size.height - the height of the copy\n   * @param {object} originDest - the destination origin (top left to paste from!)\n   * @param {number} originDest.x - the x origin of the paste\n   * @param {number} originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport, 0, this.layer);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (renderSurface.source instanceof CanvasSource) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n"],"names":["fragment","vertex","source","MaskFilter","Filter","options","sprite","rest","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","Matrix","gpuProgram","GpuProgram","glProgram","GlProgram","value","filterManager","input","output","clearMode","_BatcherPipe","renderer","adaptor","State","name","instructionSet","batchers","DefaultBatcher","i","batchableObject","batch","batches","geometry","batcher","shader","ExtensionType","BatcherPipe","extensions","tempBounds","Bounds","AlphaMaskEffect","FilterEffect","Sprite","Texture","AlphaMaskPipe","mask","maskedContainer","maskContainer","_maskedContainer","instruction","renderMask","filterEffect","BigPool","bounds","getGlobalBounds","colorTextureSource","filterTexture","TexturePool","maskData","RendererType","ColorMaskPipe","_container","colorStack","currentColor","_mask","StencilMaskPipe","_a","effect","instructionsLength","renderTargetUid","gpuRenderer","maskStackIndex","STENCIL_MODES","CLEAR","CustomRenderPipe","container","executeInstructions","renderGroup","instructions","RenderGroupPipe","batchableRenderGroup","BatchableSprite","worldTransformMatrix","SpritePipe","gpuSprite","batchableSprite","BLEND_MODE_FILTERS","BlendModePipe","renderable","blendMode","isRenderGroup","RenderGroup","warn","clearList","list","index","j","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","updateChildRenderGroups","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","childrenAtDepth","child","updateTransformAndChildren","root","worldAlpha","renderGroupParent","multiplyColors","updateFlags","localTransform","parent","updateColorBlendVisibility","children","length","groupAlpha","validateRenderables","renderPipes","rebuildRequired","tempMatrix","RenderGroupSystem","transform","originalLocalTransform","closestCacheAsTexture","resolution","antialias","scaleMode","lastTexture","texture","TextureStyle","rendererOrPipes","_BackgroundSystem","Color","BackgroundSystem","imageTypes","_ExtractSystem","defaults","image","DOMAdapter","format","quality","canvas","resolve","reject","blob","reader","target","pixelInfo","link","width","base64","style","ExtractSystem","RenderTexture","dynamic","TextureSource","height","tempRect","Rectangle","noColor","GenerateTextureSystem","clearColor","region","getLocalBounds","cleanHash","hash","clean","cleanHash2","cleanArray","arr","offset","_GCSystem","context","collection","type","gcTick","resource","gcData","last","lastResource","priority","a","b","now","managedResourceHashes","hashEntry","writeIndex","currentTick","hashValue","stopKey","hashClone","k","nullCount","key","res","GCSystem","GlobalUniformSystem","size","projectionMatrix","worldColor","renderTarget","currentGlobalUniformData","Point","globalUniformData","uniformGroup","uniforms","color32BitToUniform","bindGroup","BindGroup","uid","SchedulerSystem","Ticker","func","duration","useOffset","id","task","elapsed","saidHello","sayHello","args","VERSION","HelloSystem","_RenderableGCSystem","deprecation","_renderable","RenderableGCSystem","_TextureGCSystem","_value","TextureGCSystem","_RenderTarget","descriptor","colorSource","_size","skipColorTexture","colorTexture","RenderTarget","canvasCache","GlobalResourceRegistry","getCanvasTexture","CanvasSource","onDestroy","_ViewSystem","v8_0_0","desiredScreenWidth","desiredScreenHeight","ViewSystem","SharedSystems","RendererInitHook","SharedRenderPipes","calculateProjection","pm","x","y","flipY","sign","isRenderingToScreen","RenderTargetSystem","SystemRunner","clear","frame","mipLevel","layer","renderSurface","didChange","gpuRenderTarget","viewport","arrayLayerCount","pixelWidth","pixelHeight","scale","baseX","baseY","baseW","baseH","w","h","currentRenderTargetData","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest"],"mappings":"ubAAA,IAAIA,GAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAXC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECATC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECWb,MAAMC,WAAmBC,EAAO,CAC9B,YAAYC,EAAS,CACnB,KAAM,CAAE,OAAAC,EAAQ,GAAGC,CAAI,EAAKF,EACtBG,EAAgB,IAAIC,GAAcH,EAAO,OAAO,EAChDI,EAAiB,IAAIC,GAAa,CACtC,cAAe,CAAE,MAAO,IAAIC,EAAU,KAAM,aAAa,EACzD,WAAY,CAAE,MAAOJ,EAAc,YAAa,KAAM,WAAW,EACjE,OAAQ,CAAE,MAAO,EAAG,KAAM,KAAK,EAC/B,SAAU,CAAE,MAAOH,EAAQ,QAAU,EAAI,EAAG,KAAM,KAAK,CAC7D,CAAK,EACKQ,EAAaC,GAAW,KAAK,CACjC,OAAQ,CACN,OAAAZ,GACA,WAAY,YACpB,EACM,SAAU,CACR,OAAAA,GACA,WAAY,cACpB,CACA,CAAK,EACKa,EAAYC,GAAU,KAAK,CAC/B,OAAAf,GACA,SAAAD,GACA,KAAM,aACZ,CAAK,EACD,MAAM,CACJ,GAAGO,EACH,WAAAM,EACA,UAAAE,EACA,eAAgB,GAChB,UAAW,CACT,eAAAL,EACA,aAAcJ,EAAO,QAAQ,MACrC,CACA,CAAK,EACD,KAAK,OAASA,EACd,KAAK,eAAiBE,CACxB,CACA,IAAI,QAAQS,EAAO,CACjB,KAAK,UAAU,eAAe,SAAS,SAAWA,EAAQ,EAAI,CAChE,CACA,IAAI,SAAU,CACZ,OAAO,KAAK,UAAU,eAAe,SAAS,WAAa,CAC7D,CACA,MAAMC,EAAeC,EAAOC,EAAQC,EAAW,CAC7C,KAAK,eAAe,QAAU,KAAK,OAAO,QAC1CH,EAAc,sBACZ,KAAK,UAAU,eAAe,SAAS,cACvC,KAAK,MACX,EAAM,QAAQ,KAAK,eAAe,QAAQ,EACtC,KAAK,UAAU,aAAe,KAAK,OAAO,QAAQ,OAClDA,EAAc,YAAY,KAAMC,EAAOC,EAAQC,CAAS,CAC1D,CACF,CC3DA,MAAMC,EAAe,MAAMA,EAAa,CACtC,YAAYC,EAAUC,EAAS,CAC7B,KAAK,MAAQC,GAAM,MAAK,EACxB,KAAK,0BAA4C,OAAO,OAAO,IAAI,EAEnE,KAAK,eAAiC,OAAO,OAAO,IAAI,EACxD,KAAK,SAAWF,EAChB,KAAK,SAAWC,EAChB,KAAK,SAAS,OAAO,IAAI,CAC3B,CACA,OAAO,WAAWE,EAAM,CACtB,OAAO,IAAI,KAAK,mBAAmBA,CAAI,CACzC,CACA,WAAWC,EAAgB,CACzB,IAAIC,EAAW,KAAK,0BAA0BD,EAAe,GAAG,EAC3DC,IACHA,EAAW,KAAK,0BAA0BD,EAAe,GAAG,EAAoB,OAAO,OAAO,IAAI,EAClGC,EAAS,UAAYA,EAAS,QAAU,IAAIC,GAAe,CACzD,YAAa,KAAK,SAAS,OAAO,oBAC1C,CAAO,IAEH,KAAK,eAAiBD,EACtB,KAAK,aAAe,KAAK,eAAe,QACxC,UAAWE,KAAK,KAAK,eACnB,KAAK,eAAeA,CAAC,EAAE,MAAK,CAEhC,CACA,WAAWC,EAAiBJ,EAAgB,CAC1C,GAAI,KAAK,aAAa,OAASI,EAAgB,YAAa,CAC1D,KAAK,aAAa,MAAMJ,CAAc,EACtC,IAAIK,EAAQ,KAAK,eAAeD,EAAgB,WAAW,EACtDC,IACHA,EAAQ,KAAK,eAAeD,EAAgB,WAAW,EAAIT,GAAa,WAAWS,EAAgB,WAAW,EAC9GC,EAAM,MAAK,GAEb,KAAK,aAAeA,CACtB,CACA,KAAK,aAAa,IAAID,CAAe,CACvC,CACA,MAAMJ,EAAgB,CACpB,KAAK,aAAa,MAAMA,CAAc,CACxC,CACA,SAASA,EAAgB,CACvB,KAAK,aAAa,MAAMA,CAAc,EACtC,MAAMM,EAAU,KAAK,eACrB,UAAWH,KAAKG,EAAS,CACvB,MAAMD,EAAQC,EAAQH,CAAC,EACjBI,EAAWF,EAAM,SACvBE,EAAS,YAAY,gBAAgBF,EAAM,YAAaA,EAAM,UAAW,EAAI,EAC7EE,EAAS,QAAQ,CAAC,EAAE,gBAAgBF,EAAM,gBAAgB,YAAaA,EAAM,cAAe,EAAK,CACnG,CACF,CACA,OAAOL,EAAgB,CACrB,MAAMC,EAAW,KAAK,0BAA0BD,EAAe,GAAG,EAClE,UAAWG,KAAKF,EAAU,CACxB,MAAMO,EAAUP,EAASE,CAAC,EACpBI,EAAWC,EAAQ,SACrBA,EAAQ,QACVA,EAAQ,MAAQ,GAChBD,EAAS,QAAQ,CAAC,EAAE,OAAOC,EAAQ,cAAgB,CAAC,EAExD,CACF,CACA,QAAQH,EAAO,CACb,GAAIA,EAAM,SAAW,aAAc,CACjC,MAAMG,EAAUH,EAAM,QAChBE,EAAWC,EAAQ,SACnBC,EAASD,EAAQ,OACvB,KAAK,SAAS,MAAM,KAAMD,EAAUE,CAAM,CAC5C,CACA,KAAK,SAAS,QAAQ,KAAMJ,CAAK,CACnC,CACA,SAAU,CACR,KAAK,MAAQ,KACb,KAAK,SAAW,KAChB,KAAK,SAAW,KAChB,UAAWF,KAAK,KAAK,eACnB,KAAK,eAAeA,CAAC,EAAE,QAAO,EAEhC,KAAK,eAAiB,IACxB,CACF,EAEAR,EAAa,UAAY,CACvB,KAAM,CACJe,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACE,KAAM,OACR,EACAf,EAAa,mBAAqC,OAAO,OAAO,IAAI,EACjE,IAACgB,GAAchB,EAClBiB,EAAW,YAAYF,EAAc,QAASC,GAAY,kBAAkB,EAC5EC,EAAW,IAAIV,EAAc,ECvF7B,MAAMW,GAAa,IAAIC,EACvB,MAAMC,WAAwBC,EAAa,CACzC,aAAc,CACZ,MAAK,EACL,KAAK,QAAU,CAAC,IAAIxC,GAAW,CAC7B,OAAQ,IAAIyC,GAAOC,EAAQ,KAAK,EAChC,QAAS,GACT,WAAY,UACZ,UAAW,SACjB,CAAK,CAAC,CACJ,CACA,IAAI,QAAS,CACX,OAAO,KAAK,QAAQ,CAAC,EAAE,MACzB,CACA,IAAI,OAAO5B,EAAO,CAChB,KAAK,QAAQ,CAAC,EAAE,OAASA,CAC3B,CACA,IAAI,SAAU,CACZ,OAAO,KAAK,QAAQ,CAAC,EAAE,OACzB,CACA,IAAI,QAAQA,EAAO,CACjB,KAAK,QAAQ,CAAC,EAAE,QAAUA,CAC5B,CACF,CACA,MAAM6B,EAAc,CAClB,YAAYvB,EAAU,CACpB,KAAK,iBAAmB,CAAA,EACxB,KAAK,UAAYA,CACnB,CACA,KAAKwB,EAAMC,EAAiBrB,EAAgB,CAC1C,MAAMJ,EAAW,KAAK,UAWtB,GAVAA,EAAS,YAAY,MAAM,MAAMI,CAAc,EAC/CA,EAAe,IAAI,CACjB,aAAc,YACd,OAAQ,gBACR,KAAAoB,EACA,QAASC,EAAgB,aAAa,QACtC,UAAW,GACX,gBAAAA,CACN,CAAK,EACDD,EAAK,QAAUC,EAAgB,aAAa,QACxCD,EAAK,oBAAqB,CAC5B,MAAME,EAAgBF,EAAK,KAC3BE,EAAc,eAAiB,GAC/BA,EAAc,mBACZtB,EACAJ,EACA,IACR,EACM0B,EAAc,eAAiB,EACjC,CACA1B,EAAS,YAAY,MAAM,MAAMI,CAAc,EAC/CA,EAAe,IAAI,CACjB,aAAc,YACd,OAAQ,cACR,KAAAoB,EACA,gBAAAC,EACA,QAASA,EAAgB,aAAa,QACtC,UAAW,EACjB,CAAK,CACH,CACA,IAAID,EAAMG,EAAkBvB,EAAgB,CACzB,KAAK,UACb,YAAY,MAAM,MAAMA,CAAc,EAC/CA,EAAe,IAAI,CACjB,aAAc,YACd,OAAQ,aACR,KAAAoB,EACA,QAASG,EAAiB,aAAa,QACvC,UAAW,EACjB,CAAK,CACH,CACA,QAAQC,EAAa,CACnB,MAAM5B,EAAW,KAAK,UAChB6B,EAAaD,EAAY,KAAK,oBACpC,GAAIA,EAAY,SAAW,gBAAiB,CAC1C,MAAME,EAAeC,EAAQ,IAAIZ,EAAe,EAEhD,GADAW,EAAa,QAAUF,EAAY,QAC/BC,EAAY,CACdD,EAAY,KAAK,KAAK,WAAa,GACnC,MAAMI,EAASC,GAAgBL,EAAY,KAAK,KAAM,GAAMX,EAAU,EACtEW,EAAY,KAAK,KAAK,WAAa,GACnCI,EAAO,KAAI,EACX,MAAME,EAAqBlC,EAAS,aAAa,aAAa,aAAa,OACrEmC,EAAgBC,EAAY,kBAChCJ,EAAO,MACPA,EAAO,OACPE,EAAmB,YACnBA,EAAmB,SAC7B,EACQlC,EAAS,aAAa,KAAKmC,EAAe,EAAI,EAC9CnC,EAAS,eAAe,KAAK,CAC3B,OAAQgC,EACR,WAAY,UACtB,CAAS,EACD,MAAMjD,EAAS+C,EAAa,OAC5B/C,EAAO,QAAUoD,EACjBpD,EAAO,eAAe,GAAKiD,EAAO,KAClCjD,EAAO,eAAe,GAAKiD,EAAO,KAClC,KAAK,iBAAiB,KAAK,CACzB,aAAAF,EACA,gBAAiBF,EAAY,gBAC7B,cAAAO,CACV,CAAS,CACH,MACEL,EAAa,OAASF,EAAY,KAAK,KACvC,KAAK,iBAAiB,KAAK,CACzB,aAAAE,EACA,gBAAiBF,EAAY,eACvC,CAAS,CAEL,SAAWA,EAAY,SAAW,cAAe,CAC/C,MAAMS,EAAW,KAAK,iBAAiB,KAAK,iBAAiB,OAAS,CAAC,EACnER,IACE7B,EAAS,OAASsC,EAAa,OACjCtC,EAAS,aAAa,iBAAgB,EAExCA,EAAS,aAAa,IAAG,EACzBA,EAAS,eAAe,IAAG,GAE7BA,EAAS,OAAO,KAAK,CACnB,aAAc,SACd,OAAQ,aACR,UAAWqC,EAAS,gBACpB,aAAcA,EAAS,aACvB,UAAW,EACnB,CAAO,CACH,SAAWT,EAAY,SAAW,aAAc,CAC9C5B,EAAS,OAAO,IAAG,EACnB,MAAMqC,EAAW,KAAK,iBAAiB,IAAG,EACtCR,GACFO,EAAY,cAAcC,EAAS,aAAa,EAElDN,EAAQ,OAAOM,EAAS,YAAY,CACtC,CACF,CACA,SAAU,CACR,KAAK,UAAY,KACjB,KAAK,iBAAmB,IAC1B,CACF,CAEAd,GAAc,UAAY,CACxB,KAAM,CACJT,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACE,KAAM,WACR,EC9JA,MAAMyB,EAAc,CAClB,YAAYvC,EAAU,CACpB,KAAK,YAAc,CAAA,EACnB,KAAK,iBAAmB,EACxB,KAAK,cAAgB,EACrB,KAAK,UAAYA,CACnB,CACA,YAAa,CACX,KAAK,YAAY,CAAC,EAAI,GACtB,KAAK,iBAAmB,EACxB,KAAK,cAAgB,EACvB,CACA,KAAKwB,EAAMgB,EAAYpC,EAAgB,CACpB,KAAK,UACb,YAAY,MAAM,MAAMA,CAAc,EAC/C,MAAMqC,EAAa,KAAK,YACxBA,EAAW,KAAK,gBAAgB,EAAIA,EAAW,KAAK,iBAAmB,CAAC,EAAIjB,EAAK,KACjF,MAAMkB,EAAe,KAAK,YAAY,KAAK,gBAAgB,EACvDA,IAAiB,KAAK,gBACxB,KAAK,cAAgBA,EACrBtC,EAAe,IAAI,CACjB,aAAc,YACd,UAAWsC,EACX,UAAW,EACnB,CAAO,GAEH,KAAK,kBACP,CACA,IAAIC,EAAOH,EAAYpC,EAAgB,CACpB,KAAK,UACb,YAAY,MAAM,MAAMA,CAAc,EAC/C,MAAMqC,EAAa,KAAK,YACxB,KAAK,mBACL,MAAMC,EAAeD,EAAW,KAAK,iBAAmB,CAAC,EACrDC,IAAiB,KAAK,gBACxB,KAAK,cAAgBA,EACrBtC,EAAe,IAAI,CACjB,aAAc,YACd,UAAWsC,EACX,UAAW,EACnB,CAAO,EAEL,CACA,QAAQd,EAAa,CACF,KAAK,UACb,UAAU,QAAQA,EAAY,SAAS,CAClD,CACA,SAAU,CACR,KAAK,UAAY,KACjB,KAAK,YAAc,IACrB,CACF,CAEAW,GAAc,UAAY,CACxB,KAAM,CACJzB,EAAc,WACdA,EAAc,WAClB,EACE,KAAM,WACR,ECzDA,MAAM8B,EAAgB,CACpB,YAAY5C,EAAU,CAEpB,KAAK,eAAiB,CAAA,EACtB,KAAK,UAA4B,IAAI,QACrC,KAAK,UAAYA,CACnB,CACA,KAAKwB,EAAMgB,EAAYpC,EAAgB,CACrC,IAAIyC,EACJ,MAAMC,EAAStB,EACTxB,EAAW,KAAK,UACtBA,EAAS,YAAY,MAAM,MAAMI,CAAc,EAC/CJ,EAAS,YAAY,UAAU,aAAa8C,EAAO,KAAM,OAAQ1C,CAAc,EAC/EA,EAAe,IAAI,CACjB,aAAc,cACd,OAAQ,gBACR,KAAAoB,EACA,QAASgB,EAAW,aAAa,QACjC,UAAW,EACjB,CAAK,EACD,MAAMd,EAAgBoB,EAAO,KAC7BpB,EAAc,eAAiB,GAC1B,KAAK,UAAU,IAAIoB,CAAM,GAC5B,KAAK,UAAU,IAAIA,EAAQ,CACzB,kBAAmB,EACnB,mBAAoB,CAC5B,CAAO,EAEH,MAAMT,EAAW,KAAK,UAAU,IAAIS,CAAM,EAC1CT,EAAS,kBAAoBjC,EAAe,gBAC5CsB,EAAc,mBACZtB,EACAJ,EACA,IACN,EACI0B,EAAc,eAAiB,GAC/B1B,EAAS,YAAY,MAAM,MAAMI,CAAc,EAC/CA,EAAe,IAAI,CACjB,aAAc,cACd,OAAQ,cACR,KAAAoB,EACA,QAASgB,EAAW,aAAa,QACjC,UAAW,EACjB,CAAK,EACD,MAAMO,EAAqB3C,EAAe,gBAAkBiC,EAAS,kBAAoB,EACzFA,EAAS,mBAAqBU,EAC9B,MAAMC,EAAkBhD,EAAS,aAAa,aAAa,KAC1D6C,EAAK,KAAK,gBAAgBG,CAAe,IAAMH,EAAGG,CAAe,EAAI,EACxE,CACA,IAAIxB,EAAMgB,EAAYpC,EAAgB,CACpC,MAAM0C,EAAStB,EACTxB,EAAW,KAAK,UACtBA,EAAS,YAAY,MAAM,MAAMI,CAAc,EAC/CJ,EAAS,YAAY,UAAU,aAAa8C,EAAO,KAAM,OAAQ1C,CAAc,EAC/EA,EAAe,IAAI,CACjB,aAAc,cACd,OAAQ,eACR,QAASoC,EAAW,aAAa,QACjC,UAAW,EACjB,CAAK,EACD,MAAMH,EAAW,KAAK,UAAU,IAAIb,CAAI,EACxC,QAASjB,EAAI,EAAGA,EAAI8B,EAAS,mBAAoB9B,IAC/CH,EAAe,aAAaA,EAAe,iBAAiB,EAAIA,EAAe,aAAaiC,EAAS,mBAAmB,EAE1HjC,EAAe,IAAI,CACjB,aAAc,cACd,OAAQ,aACR,UAAW,EACjB,CAAK,CACH,CACA,QAAQwB,EAAa,CACnB,IAAIiB,EACJ,MAAM7C,EAAW,KAAK,UAChBiD,EAAcjD,EACdgD,EAAkBhD,EAAS,aAAa,aAAa,IAC3D,IAAIkD,GAAkBL,EAAK,KAAK,gBAAgBG,CAAe,IAAMH,EAAGG,CAAe,EAAI,GACvFpB,EAAY,SAAW,iBACzBqB,EAAY,aAAa,mBAAkB,EAC3CA,EAAY,QAAQ,eAAeE,EAAc,mBAAoBD,CAAc,EACnFA,IACAD,EAAY,UAAU,QAAQ,CAAC,GACtBrB,EAAY,SAAW,eAC5BA,EAAY,QACdqB,EAAY,QAAQ,eAAeE,EAAc,oBAAqBD,CAAc,EAEpFD,EAAY,QAAQ,eAAeE,EAAc,YAAaD,CAAc,EAE9ED,EAAY,UAAU,QAAQ,EAAE,GACvBrB,EAAY,SAAW,gBAChCqB,EAAY,UAAU,QAAQ,CAAC,EAC3BC,IAAmB,EACrBD,EAAY,QAAQ,eAAeE,EAAc,sBAAuBD,CAAc,GAEtFD,EAAY,aAAa,MAAM,KAAMG,EAAM,OAAO,EAClDH,EAAY,QAAQ,eAAeE,EAAc,SAAUD,CAAc,GAE3EA,KACStB,EAAY,SAAW,eAC5BA,EAAY,QACdqB,EAAY,QAAQ,eAAeE,EAAc,oBAAqBD,CAAc,EAEpFD,EAAY,QAAQ,eAAeE,EAAc,YAAaD,CAAc,EAE9ED,EAAY,UAAU,QAAQ,EAAE,GAElC,KAAK,eAAeD,CAAe,EAAIE,CACzC,CACA,SAAU,CACR,KAAK,UAAY,KACjB,KAAK,eAAiB,KACtB,KAAK,UAAY,IACnB,CACF,CACAN,GAAgB,UAAY,CAC1B,KAAM,CACJ9B,EAAc,WACdA,EAAc,WAClB,EACE,KAAM,aACR,ECzHA,MAAMuC,EAAiB,CACrB,YAAYrD,EAAU,CACpB,KAAK,UAAYA,CACnB,CACA,kBAAmB,CACnB,CACA,mBAAoB,CACpB,CACA,oBAAqB,CACnB,MAAO,EACT,CACA,cAAcsD,EAAWlD,EAAgB,CACvC,KAAK,UAAU,YAAY,MAAM,MAAMA,CAAc,EACrDA,EAAe,IAAIkD,CAAS,CAC9B,CACA,QAAQA,EAAW,CACZA,EAAU,cACfA,EAAU,OAAO,KAAK,SAAS,CACjC,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACF,CACAD,GAAiB,UAAY,CAC3B,KAAM,CACJvC,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACE,KAAM,cACR,EChCA,SAASyC,EAAoBC,EAAaxD,EAAU,CAClD,MAAMI,EAAiBoD,EAAY,eAC7BC,EAAerD,EAAe,aACpC,QAASG,EAAI,EAAGA,EAAIH,EAAe,gBAAiBG,IAAK,CACvD,MAAMqB,EAAc6B,EAAalD,CAAC,EAClCP,EAAS4B,EAAY,YAAY,EAAE,QAAQA,CAAW,CACxD,CACF,CCDA,MAAM8B,EAAgB,CACpB,YAAY1D,EAAU,CACpB,KAAK,UAAYA,CACnB,CACA,eAAewD,EAAapD,EAAgB,CACtCoD,EAAY,kBACd,KAAK,6BAA6BA,EAAapD,CAAc,EAE7D,KAAK,qBAAqBoD,EAAapD,CAAc,CAEzD,CACA,QAAQoD,EAAa,CACdA,EAAY,eACbA,EAAY,kBACd,KAAK,uBAAuBA,CAAW,EAEvC,KAAK,eAAeA,CAAW,EAEnC,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACA,qBAAqBA,EAAapD,EAAgB,CAChD,KAAK,UAAU,YAAY,MAAM,MAAMA,CAAc,EACjDoD,EAAY,wBACdzB,EAAQ,OAAOyB,EAAY,qBAAqB,EAChDA,EAAY,sBAAwB,MAEtCpD,EAAe,IAAIoD,CAAW,CAChC,CACA,6BAA6BA,EAAapD,EAAgB,CACxD,MAAMuD,EAAuBH,EAAY,wBAA0BA,EAAY,sBAAwBzB,EAAQ,IAAI6B,EAAe,GAClID,EAAqB,WAAaH,EAAY,KAC9CG,EAAqB,UAAYH,EAAY,KAAK,uBAClDG,EAAqB,QAAUH,EAAY,QAC3CG,EAAqB,OAASH,EAAY,eAC1CpD,EAAe,IAAIoD,CAAW,EAC9B,KAAK,UAAU,YAAY,UAAU,cAAcA,EAAaA,EAAY,KAAK,eAAgBpD,CAAc,EAC/G,KAAK,UAAU,YAAY,MAAM,WAAWuD,EAAsBvD,CAAc,EAChF,KAAK,UAAU,YAAY,UAAU,aAAaA,CAAc,CAClE,CACA,uBAAuBoD,EAAa,CAClC,GAAIA,EAAY,mBAAoB,CAClCA,EAAY,mBAAqB,GACjC,MAAMK,EAAuB,IAAIxE,EAAM,EAAG,UACxC,CAACmE,EAAY,eAAe,EAC5B,CAACA,EAAY,eAAe,CACpC,EACM,KAAK,UAAU,aAAa,KAAKA,EAAY,QAAS,GAAM,KAAMA,EAAY,QAAQ,KAAK,EAC3F,KAAK,UAAU,eAAe,KAAK,CACjC,qBAAAK,EACA,WAAY,WACZ,OAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,CAC5B,CAAO,EACDN,EAAoBC,EAAa,KAAK,UAAU,WAAW,EAC3D,KAAK,UAAU,aAAa,iBAAgB,EAC5C,KAAK,UAAU,aAAa,IAAG,EAC/B,KAAK,UAAU,eAAe,IAAG,CACnC,CACAA,EAAY,sBAAsB,SAAS,cAAcA,EAAY,qBAAqB,EAC1FA,EAAY,sBAAsB,SAAS,SAAS,QAAQ,CAAC,EAAE,OAAM,CACvE,CACA,eAAeA,EAAa,CAC1B,KAAK,UAAU,eAAe,KAAK,CACjC,qBAAsBA,EAAY,8BAClC,WAAYA,EAAY,eAC9B,CAAK,EACDD,EAAoBC,EAAa,KAAK,UAAU,WAAW,EAC3D,KAAK,UAAU,eAAe,IAAG,CACnC,CACF,CACAE,GAAgB,UAAY,CAC1B,KAAM,CACJ5C,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACE,KAAM,aACR,ECjFA,MAAMgD,EAAW,CACf,YAAY9D,EAAU,CACpB,KAAK,UAAYA,CACnB,CACA,cAAcjB,EAAQqB,EAAgB,CACpC,MAAM2D,EAAY,KAAK,cAAchF,CAAM,EACvCA,EAAO,eAAe,KAAK,uBAAuBA,EAAQgF,CAAS,EACvE,KAAK,UAAU,YAAY,MAAM,WAAWA,EAAW3D,CAAc,CACvE,CACA,iBAAiBrB,EAAQ,CACvB,MAAMgF,EAAY,KAAK,cAAchF,CAAM,EACvCA,EAAO,eAAe,KAAK,uBAAuBA,EAAQgF,CAAS,EACvEA,EAAU,SAAS,cAAcA,CAAS,CAC5C,CACA,mBAAmBhF,EAAQ,CACzB,MAAMgF,EAAY,KAAK,cAAchF,CAAM,EAC3C,MAAO,CAACgF,EAAU,SAAS,sBACzBA,EACAhF,EAAO,QACb,CACE,CACA,uBAAuBA,EAAQiF,EAAiB,CAC9CA,EAAgB,OAASjF,EAAO,aAChCiF,EAAgB,QAAUjF,EAAO,QACnC,CACA,cAAcA,EAAQ,CACpB,OAAOA,EAAO,SAAS,KAAK,UAAU,GAAG,GAAK,KAAK,eAAeA,CAAM,CAC1E,CACA,eAAeA,EAAQ,CACrB,MAAMiF,EAAkB,IAAIJ,GAC5B,OAAAI,EAAgB,WAAajF,EAC7BiF,EAAgB,UAAYjF,EAAO,eACnCiF,EAAgB,QAAUjF,EAAO,SACjCiF,EAAgB,OAASjF,EAAO,aAChCiF,EAAgB,YAAc,KAAK,UAAU,aAAejF,EAAO,aACnEA,EAAO,SAAS,KAAK,UAAU,GAAG,EAAIiF,EAC/BA,CACT,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACF,CAEAF,GAAW,UAAY,CACrB,KAAM,CACJhD,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACE,KAAM,QACR,EChDA,MAAMmD,EAAqB,CAAA,EAC3BjD,EAAW,OAAOF,EAAc,UAAYpB,GAAU,CACpD,GAAI,CAACA,EAAM,KACT,MAAM,IAAI,MAAM,+CAA+C,EAEjEuE,EAAmBvE,EAAM,IAAI,EAAIA,EAAM,GACzC,EAAIA,GAAU,CACZ,OAAOuE,EAAmBvE,EAAM,IAAI,CACtC,CAAC,EACD,MAAMwE,EAAc,CAClB,YAAYlE,EAAU,CACpB,KAAK,gBAAkB,CAAA,EACvB,KAAK,YAAc,GACnB,KAAK,YAA8B,OAAO,OAAO,IAAI,EACrD,KAAK,UAAYA,EACjB,KAAK,UAAU,QAAQ,UAAU,IAAI,IAAI,CAC3C,CACA,WAAY,CACV,KAAK,iBAAmB,SACxB,KAAK,YAAc,EACrB,CAOA,cAAcmE,EAAYC,EAAWhE,EAAgB,CACnD,KAAK,gBAAgB,KAAKgE,CAAS,EACnC,KAAK,aAAaD,EAAYC,EAAWhE,CAAc,CACzD,CAKA,aAAaA,EAAgB,CAC3B,KAAK,gBAAgB,IAAG,EACxB,MAAMgE,EAAY,KAAK,gBAAgB,KAAK,iBAAiB,OAAS,CAAC,GAAK,SAC5E,KAAK,aAAa,KAAMA,EAAWhE,CAAc,CACnD,CASA,aAAa+D,EAAYC,EAAWhE,EAAgB,CAClD,MAAMiE,EAAgBF,aAAsBG,GAC5C,GAAI,KAAK,mBAAqBF,EAAW,CACnC,KAAK,aAAeD,GAAc,CAACE,GACrC,KAAK,iBAAiB,KAAKF,CAAU,EAEvC,MACF,CACI,KAAK,aAAa,KAAK,sBAAsB/D,CAAc,EAC/D,KAAK,iBAAmBgE,EACnBD,IACL,KAAK,YAAc,CAAC,CAACF,EAAmBG,CAAS,EAC7C,KAAK,aAAa,KAAK,wBAAwBD,EAAY/D,CAAc,EAC/E,CACA,wBAAwB+D,EAAY/D,EAAgB,CAClD,KAAK,UAAU,YAAY,MAAM,MAAMA,CAAc,EACrD,MAAMgE,EAAY,KAAK,iBACvB,GAAI,CAACH,EAAmBG,CAAS,EAAG,CAClCG,GAAK,gCAAgCH,CAAS,mEAAmE,EACjH,MACF,CACA,MAAMtC,EAAe,KAAK,oBAAoBsC,CAAS,EACjDC,EAAgBF,aAAsBG,GACtC1C,EAAc,CAClB,aAAc,SACd,OAAQ,aACR,aAAAE,EACA,YAAauC,EAAgB,KAAO,CAACF,CAAU,EAC/C,UAAWE,EAAgBF,EAAW,KAAO,KAC7C,UAAW,EACjB,EACI,KAAK,gBAAkBvC,EAAY,YACnCxB,EAAe,IAAIwB,CAAW,CAChC,CACA,oBAAoBwC,EAAW,CAC7B,IAAItC,EAAe,KAAK,YAAYsC,CAAS,EAC7C,OAAKtC,IACHA,EAAe,KAAK,YAAYsC,CAAS,EAAI,IAAIhD,GACjDU,EAAa,QAAU,CAAC,IAAImC,EAAmBG,CAAS,CAAG,GAEtDtC,CACT,CACA,sBAAsB1B,EAAgB,CACpC,KAAK,YAAc,GACnB,KAAK,gBAAkB,KACvB,KAAK,UAAU,YAAY,MAAM,MAAMA,CAAc,EACrDA,EAAe,IAAI,CACjB,aAAc,SACd,OAAQ,YACR,UAAW,EACjB,CAAK,CACH,CAKA,YAAa,CACX,KAAK,YAAc,EACrB,CAOA,SAASA,EAAgB,CAClB,KAAK,aACV,KAAK,sBAAsBA,CAAc,CAC3C,CAEA,SAAU,CACR,KAAK,UAAY,KACjB,KAAK,gBAAkB,KACvB,UAAWG,KAAK,KAAK,YACnB,KAAK,YAAYA,CAAC,EAAE,QAAO,EAE7B,KAAK,YAAc,IACrB,CACF,CAEA2D,GAAc,UAAY,CACxB,KAAM,CACJpD,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACE,KAAM,WACR,EC5IA,SAAS0D,EAAUC,EAAMC,EAAO,CAC9BA,IAAUA,EAAQ,GAClB,QAASC,EAAID,EAAOC,EAAIF,EAAK,QACvBA,EAAKE,CAAC,EADyBA,IAEjCF,EAAKE,CAAC,EAAI,IAKhB,CCLA,MAAMC,GAAgB,IAAIC,EACpBC,GAA6BC,GAAiBC,GAAeC,GACnE,SAASC,GAA4B1B,EAAa2B,EAA0B,GAAO,CACjFC,GAA2B5B,CAAW,EACtC,MAAM6B,EAAmB7B,EAAY,iBAC/B8B,EAAa9B,EAAY,aAC/B,UAAWmB,KAAKU,EAAkB,CAChC,MAAME,EAAmB,OAAOZ,CAAC,EAC3Ba,EAAkBH,EAAiBV,CAAC,EACpCF,EAAOe,EAAgB,KACvBd,EAAQc,EAAgB,MAC9B,QAASjF,EAAI,EAAGA,EAAImE,EAAOnE,IAAK,CAC9B,MAAMkF,EAAQhB,EAAKlE,CAAC,EAChBkF,EAAM,oBAAsBjC,GAAeiC,EAAM,2BAA6BF,GAChFG,GAA2BD,EAAOH,EAAY,CAAC,CAEnD,CACAd,EAAUC,EAAMC,CAAK,EACrBc,EAAgB,MAAQ,CAC1B,CACA,GAAIL,EACF,QAAS5E,EAAI,EAAGA,EAAIiD,EAAY,oBAAoB,OAAQjD,IAC1D2E,GAA4B1B,EAAY,oBAAoBjD,CAAC,EAAG4E,CAAuB,CAG7F,CACA,SAASC,GAA2B5B,EAAa,CAC/C,MAAMmC,EAAOnC,EAAY,KACzB,IAAIoC,EACJ,GAAIpC,EAAY,kBAAmB,CACjC,MAAMqC,EAAoBrC,EAAY,kBACtCA,EAAY,eAAe,WACzBmC,EAAK,uBACLE,EAAkB,cACxB,EACIrC,EAAY,WAAasC,GACvBH,EAAK,WACLE,EAAkB,UACxB,EACID,EAAaD,EAAK,WAAaE,EAAkB,UACnD,MACErC,EAAY,eAAe,SAASmC,EAAK,cAAc,EACvDnC,EAAY,WAAamC,EAAK,WAC9BC,EAAaD,EAAK,WAEpBC,EAAaA,EAAa,EAAI,EAAIA,EAAa,EAAI,EAAIA,EACvDpC,EAAY,WAAaoC,EACzBpC,EAAY,gBAAkBA,EAAY,aAAeoC,EAAa,IAAM,IAAM,GACpF,CACA,SAASF,GAA2BpC,EAAWgC,EAAYS,EAAa,CACtE,GAAIT,IAAehC,EAAU,WAAY,OACzCA,EAAU,WAAagC,EACvBhC,EAAU,UAAY,GACtB,MAAM0C,EAAiB1C,EAAU,eACjCA,EAAU,qBAAoB,EAC9B,MAAM2C,EAAS3C,EAAU,OAiBzB,GAhBI2C,GAAU,CAACA,EAAO,aACpBF,GAAezC,EAAU,aACzBA,EAAU,uBAAuB,WAC/B0C,EACAC,EAAO,sBACb,EACQF,EAAcjB,IAChBoB,GAA2B5C,EAAW2C,EAAQF,CAAW,IAG3DA,EAAczC,EAAU,aACxBA,EAAU,uBAAuB,SAAS0C,CAAc,EACpDD,EAAcjB,IAChBoB,GAA2B5C,EAAWsB,GAAemB,CAAW,GAGhE,CAACzC,EAAU,YAAa,CAC1B,MAAM6C,EAAW7C,EAAU,SACrB8C,EAASD,EAAS,OACxB,QAAS5F,EAAI,EAAGA,EAAI6F,EAAQ7F,IAC1BmF,GAA2BS,EAAS5F,CAAC,EAAG+E,EAAYS,CAAW,EAEjE,MAAMvC,EAAcF,EAAU,kBACxBa,EAAab,EACfa,EAAW,cAAgB,CAACX,EAAY,oBAC1CA,EAAY,iBAAiBW,CAAU,CAE3C,CACF,CACA,SAAS+B,GAA2B5C,EAAW2C,EAAQF,EAAa,CAClE,GAAIA,EAAcf,GAAc,CAC9B1B,EAAU,WAAawC,GACrBxC,EAAU,WACV2C,EAAO,UACb,EACI,IAAII,EAAa/C,EAAU,WAAa2C,EAAO,WAC/CI,EAAaA,EAAa,EAAI,EAAIA,EAAa,EAAI,EAAIA,EACvD/C,EAAU,WAAa+C,EACvB/C,EAAU,gBAAkBA,EAAU,aAAe+C,EAAa,IAAM,IAAM,GAChF,CACIN,EAAcd,KAChB3B,EAAU,eAAiBA,EAAU,iBAAmB,UAAY2C,EAAO,eAAiB3C,EAAU,gBAEpGyC,EAAchB,KAChBzB,EAAU,oBAAsBA,EAAU,mBAAqB2C,EAAO,qBAExE3C,EAAU,aAAe,CAC3B,CC3GA,SAASgD,GAAoB9C,EAAa+C,EAAa,CACrD,KAAM,CAAE,KAAA9B,GAASjB,EAAY,4BAC7B,IAAIgD,EAAkB,GACtB,QAASjG,EAAI,EAAGA,EAAIiD,EAAY,4BAA4B,MAAOjD,IAAK,CACtE,MAAM+C,EAAYmB,EAAKlE,CAAC,EAIxB,GADAiG,EADaD,EADMjD,EACiB,YAAY,EACzB,mBAAmBA,CAAS,EAC/CkD,EACF,KAEJ,CACA,OAAAhD,EAAY,mBAAqBgD,EAC1BA,CACT,CCJA,MAAMC,GAAa,IAAIpH,EACvB,MAAMqH,EAAkB,CACtB,YAAY1G,EAAU,CACpB,KAAK,UAAYA,CACnB,CACA,OAAO,CAAE,UAAAsD,EAAW,UAAAqD,GAAa,CAC/B,MAAMV,EAAS3C,EAAU,OACnBuC,EAAoBvC,EAAU,YAAY,kBAChDA,EAAU,OAAS,KACnBA,EAAU,YAAY,kBAAoB,KAC1C,MAAMtD,EAAW,KAAK,UAChB4G,EAAyBH,GAC3BE,IACFC,EAAuB,SAAStD,EAAU,YAAY,cAAc,EACpEA,EAAU,YAAY,eAAe,SAASqD,CAAS,GAEzD,MAAMJ,EAAcvG,EAAS,YAC7B,KAAK,0BAA0BsD,EAAU,YAAa,IAAI,EAC1D,KAAK,oBAAoBA,EAAU,WAAW,EAC9CtD,EAAS,eAAe,MAAM,CAC5B,qBAAsB2G,EAAYrD,EAAU,YAAY,eAAiBA,EAAU,YAAY,eAC/F,WAAYA,EAAU,YAAY,eACxC,CAAK,EACDC,EAAoBD,EAAU,YAAaiD,CAAW,EAClDA,EAAY,cACdA,EAAY,aAAa,UAAS,EAEhCI,GACFrD,EAAU,YAAY,eAAe,SAASsD,CAAsB,EAEtEtD,EAAU,OAAS2C,EACnB3C,EAAU,YAAY,kBAAoBuC,CAC5C,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACA,0BAA0BrC,EAAaqD,EAAuB,CAE5D,GADArD,EAAY,iCAAmCqD,EAC3CrD,EAAY,kBAAmB,CACjC,GAAI,CAACA,EAAY,mBAAoB,OACrCqD,EAAwBrD,CAC1B,CACA,QAASjD,EAAIiD,EAAY,oBAAoB,OAAS,EAAGjD,GAAK,EAAGA,IAC/D,KAAK,0BAA0BiD,EAAY,oBAAoBjD,CAAC,EAAGsG,CAAqB,EAG1F,GADArD,EAAY,mBAAkB,EAC1BA,EAAY,mBACd,GAAIA,EAAY,mBAAoB,CAClC,MAAMxB,EAASwB,EAAY,KAAK,eAAc,EACxCxD,EAAW,KAAK,UAChB8G,EAAatD,EAAY,eAAe,YAAcxD,EAAS,KAAK,WACpE+G,EAAYvD,EAAY,eAAe,WAAaxD,EAAS,KAAK,UAClEgH,EAAYxD,EAAY,eAAe,WAAa,SACpDyD,EAAczD,EAAY,QAChCxB,EAAO,KAAI,EACPwB,EAAY,SACdpB,EAAY,cAAcoB,EAAY,QAAS,EAAI,EAErD,MAAM0D,EAAU9E,EAAY,kBAC1BJ,EAAO,MACPA,EAAO,OACP8E,EACAC,CACV,EACQG,EAAQ,QAAQ,MAAQ,IAAIC,GAAa,CAAE,UAAAH,CAAS,CAAE,EACtDxD,EAAY,QAAU0D,EACtB1D,EAAY,iBAAmBA,EAAY,eAAiB,IAAItC,GAChEsC,EAAY,eAAe,SAASxB,CAAM,EACtCiF,IAAgBzD,EAAY,SAC1BA,EAAY,oBACdA,EAAY,kBAAkB,mBAAqB,GAGzD,OACSA,EAAY,UACrBpB,EAAY,cAAcoB,EAAY,QAAS,EAAI,EACnDA,EAAY,QAAU,KAE1B,CACA,oBAAoBA,EAAa,CAC/B,MAAMxD,EAAW,KAAK,UAChBuG,EAAcvG,EAAS,YAiB7B,GAhBAwD,EAAY,YAAYxD,CAAQ,EAChCwD,EAAY,eAAe,YAAc+C,EACpC/C,EAAY,mBAGfgB,EAAUhB,EAAY,4BAA4B,KAAM,CAAC,EAFzD8C,GAAoB9C,EAAa+C,CAAW,EAI9CrB,GAA4B1B,CAAW,EACnCA,EAAY,oBACdA,EAAY,mBAAqB,GACjC,KAAK,mBAAmBA,EAAaxD,CAAQ,GAE7C,KAAK,mBAAmBwD,CAAW,EAErCA,EAAY,4BAA4B,MAAQ,EAChDxD,EAAS,YAAY,MAAM,OAAOwD,EAAY,cAAc,EACxD,EAAAA,EAAY,mBAAqB,CAACA,EAAY,oBAClD,QAASjD,EAAI,EAAGA,EAAIiD,EAAY,oBAAoB,OAAQjD,IAC1D,KAAK,oBAAoBiD,EAAY,oBAAoBjD,CAAC,CAAC,CAE/D,CACA,mBAAmBiD,EAAa,CAC9B,KAAM,CAAE,KAAAiB,EAAM,MAAAC,CAAK,EAAKlB,EAAY,4BACpC,QAASjD,EAAI,EAAGA,EAAImE,EAAOnE,IAAK,CAC9B,MAAM+C,EAAYmB,EAAKlE,CAAC,EACpB+C,EAAU,eACZE,EAAY,iBAAiBF,CAAS,CAE1C,CACAkB,EAAUC,EAAMC,CAAK,CACvB,CACA,mBAAmBlB,EAAa4D,EAAiB,CAC/C,MAAMzB,EAAOnC,EAAY,KACnBpD,EAAiBoD,EAAY,eACnCpD,EAAe,MAAK,EACpB,MAAMJ,EAAWoH,EAAgB,YAAcA,EAAkBA,EAAgB,MAAM,SACjFb,EAAcvG,EAAS,YAC7BuG,EAAY,MAAM,WAAWnG,CAAc,EAC3CmG,EAAY,UAAU,WAAU,EAChCA,EAAY,UAAU,WAAU,EAC5BZ,EAAK,kBACPA,EAAK,aAAY,EAEnBA,EAAK,8BAA8BvF,EAAgBJ,EAAU,IAAI,EACjEuG,EAAY,MAAM,SAASnG,CAAc,EACzCmG,EAAY,UAAU,SAASnG,CAAc,CAC/C,CACF,CAEAsG,GAAkB,UAAY,CAC5B,KAAM,CACJ5F,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,aACR,EChJA,MAAMuG,EAAoB,MAAMA,EAAkB,CAChD,aAAc,CACZ,KAAK,kBAAoB,GACzB,KAAK,iBAAmB,IAAIC,EAAM,CAAC,EACnC,KAAK,MAAQ,KAAK,iBAClB,KAAK,MAAQ,CACf,CAKA,KAAKxI,EAAS,CACZA,EAAU,CAAE,GAAGuI,GAAkB,eAAgB,GAAGvI,CAAO,EAC3D,KAAK,kBAAoBA,EAAQ,kBACjC,KAAK,MAAQA,EAAQ,YAAcA,EAAQ,iBAAmB,KAAK,iBACnE,KAAK,MAAQA,EAAQ,gBACrB,KAAK,iBAAiB,SAASA,EAAQ,eAAe,CACxD,CAEA,IAAI,OAAQ,CACV,OAAO,KAAK,gBACd,CACA,IAAI,MAAMY,EAAO,CACE4H,EAAM,OAAO,SAAS5H,CAAK,EAC/B,MAAQ,GAAK,KAAK,iBAAiB,QAAU,GACxD6E,GACE,8IACR,EAEI,KAAK,iBAAiB,SAAS7E,CAAK,CACtC,CAEA,IAAI,OAAQ,CACV,OAAO,KAAK,iBAAiB,KAC/B,CACA,IAAI,MAAMA,EAAO,CACf,KAAK,iBAAiB,SAASA,CAAK,CACtC,CAEA,IAAI,WAAY,CACd,OAAO,KAAK,iBAAiB,QAAO,CACtC,CAKA,SAAU,CACV,CACF,EAEA2H,EAAkB,UAAY,CAC5B,KAAM,CACJvG,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,aACN,SAAU,CACZ,EAEAuG,EAAkB,eAAiB,CAKjC,gBAAiB,EAKjB,gBAAiB,EAKjB,kBAAmB,EACrB,EACA,IAAIE,GAAmBF,EC5EvB,MAAMG,EAAa,CACjB,IAAK,YACL,IAAK,aACL,KAAM,YACR,EACMC,EAAiB,MAAMA,EAAe,CAE1C,YAAYzH,EAAU,CACpB,KAAK,UAAYA,CACnB,CACA,kBAAkBlB,EAAS4I,EAAW,GAAI,CACxC,OAAI5I,aAAmB+F,GAAa/F,aAAmBwC,EAC9C,CACL,OAAQxC,EACR,GAAG4I,CACX,EAEW,CACL,GAAGA,EACH,GAAG5I,CACT,CACE,CAiCA,MAAM,MAAMA,EAAS,CACnB,MAAM6I,EAAQC,EAAW,IAAG,EAAG,YAAW,EAC1C,OAAAD,EAAM,IAAM,MAAM,KAAK,OAAO7I,CAAO,EAC9B6I,CACT,CAiCA,MAAM,OAAO7I,EAAS,CACpBA,EAAU,KAAK,kBACbA,EACA2I,GAAe,mBACrB,EACI,KAAM,CAAE,OAAAI,EAAQ,QAAAC,CAAO,EAAKhJ,EACtBiJ,EAAS,KAAK,OAAOjJ,CAAO,EAClC,GAAIiJ,EAAO,SAAW,OACpB,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtCF,EAAO,OAAQG,GAAS,CACtB,GAAI,CAACA,EAAM,CACTD,EAAO,IAAI,MAAM,wBAAwB,CAAC,EAC1C,MACF,CACA,MAAME,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAMH,EAAQG,EAAO,MAAM,EAC3CA,EAAO,QAAUF,EACjBE,EAAO,cAAcD,CAAI,CAC3B,EAAGV,EAAWK,CAAM,EAAGC,CAAO,CAChC,CAAC,EAEH,GAAIC,EAAO,YAAc,OACvB,OAAOA,EAAO,UAAUP,EAAWK,CAAM,EAAGC,CAAO,EAErD,GAAIC,EAAO,gBAAkB,OAAQ,CACnC,MAAMG,EAAO,MAAMH,EAAO,cAAc,CAAE,KAAMP,EAAWK,CAAM,EAAG,QAAAC,EAAS,EAC7E,OAAO,IAAI,QAAQ,CAACE,EAASC,IAAW,CACtC,MAAME,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAMH,EAAQG,EAAO,MAAM,EAC3CA,EAAO,QAAUF,EACjBE,EAAO,cAAcD,CAAI,CAC3B,CAAC,CACH,CACA,MAAM,IAAI,MAAM,yGAAyG,CAC3H,CAyCA,OAAOpJ,EAAS,CACdA,EAAU,KAAK,kBAAkBA,CAAO,EACxC,MAAMsJ,EAAStJ,EAAQ,OACjBkB,EAAW,KAAK,UACtB,GAAIoI,aAAkB9G,EACpB,OAAOtB,EAAS,QAAQ,eAAeoI,CAAM,EAE/C,MAAMlB,EAAUlH,EAAS,iBAAiB,gBAAgBlB,CAAO,EAC3DiJ,EAAS/H,EAAS,QAAQ,eAAekH,CAAO,EACtD,OAAAA,EAAQ,QAAQ,EAAI,EACba,CACT,CA+BA,OAAOjJ,EAAS,CACdA,EAAU,KAAK,kBAAkBA,CAAO,EACxC,MAAMsJ,EAAStJ,EAAQ,OACjBkB,EAAW,KAAK,UAChBkH,EAAUkB,aAAkB9G,EAAU8G,EAASpI,EAAS,iBAAiB,gBAAgBlB,CAAO,EAChGuJ,EAAYrI,EAAS,QAAQ,UAAUkH,CAAO,EACpD,OAAIkB,aAAkBvD,GACpBqC,EAAQ,QAAQ,EAAI,EAEfmB,CACT,CA4CA,QAAQvJ,EAAS,CAEf,OADAA,EAAU,KAAK,kBAAkBA,CAAO,EACpCA,EAAQ,kBAAkBwC,EAAgBxC,EAAQ,OAC/C,KAAK,UAAU,iBAAiB,gBAAgBA,CAAO,CAChE,CA6CA,SAASA,EAAS,CAChBA,EAAU,KAAK,kBAAkBA,CAAO,EACxC,MAAMiJ,EAAS,KAAK,OAAOjJ,CAAO,EAC5BwJ,EAAO,SAAS,cAAc,GAAG,EACvCA,EAAK,SAAWxJ,EAAQ,UAAY,YACpCwJ,EAAK,KAAOP,EAAO,UAAU,WAAW,EACxC,SAAS,KAAK,YAAYO,CAAI,EAC9BA,EAAK,MAAK,EACV,SAAS,KAAK,YAAYA,CAAI,CAChC,CAiBA,IAAIxJ,EAAS,CACX,MAAMyJ,EAAQzJ,EAAQ,OAAS,IAC/BA,EAAU,KAAK,kBAAkBA,CAAO,EACxC,MAAMiJ,EAAS,KAAK,OAAOjJ,CAAO,EAC5B0J,EAAST,EAAO,UAAS,EAC/B,QAAQ,IAAI,kBAAkBA,EAAO,KAAK,MAAMA,EAAO,MAAM,IAAI,EACjE,MAAMU,EAAQ,CACZ,kBACA,YAAYF,CAAK,YACjB,mBAAmBC,CAAM,eACzB,2BACN,EAAM,KAAK,GAAG,EACV,QAAQ,IAAI,MAAOC,CAAK,CAC1B,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACF,EAEAhB,EAAe,UAAY,CACzB,KAAM,CACJ3G,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,SACR,EAaA2G,EAAe,oBAAsB,CACnC,OAAQ,MACR,QAAS,CACX,EACA,IAAIiB,GAAgBjB,EC9XpB,MAAMkB,UAAsBrH,CAAQ,CASlC,OAAO,OAAOxC,EAAS,CACrB,KAAM,CAAE,QAAA8J,EAAS,GAAG5J,CAAI,EAAKF,EAC7B,OAAO,IAAI6J,EAAc,CACvB,OAAQ,IAAIE,EAAc7J,CAAI,EAC9B,QAAS4J,GAAW,EAC1B,CAAK,CACH,CAQA,OAAOL,EAAOO,EAAQhC,EAAY,CAChC,YAAK,OAAO,OAAOyB,EAAOO,EAAQhC,CAAU,EACrC,IACT,CACF,CCrBA,MAAMiC,GAAW,IAAIC,EACf/H,GAAa,IAAIC,EACjB+H,GAAU,CAAC,EAAG,EAAG,EAAG,CAAC,EAC3B,MAAMC,EAAsB,CAC1B,YAAYlJ,EAAU,CACpB,KAAK,UAAYA,CACnB,CAqCA,gBAAgBlB,EAAS,CACnBA,aAAmB+F,IACrB/F,EAAU,CACR,OAAQA,EACR,MAAO,OACP,qBAAsB,CAAA,EACtB,WAAY,MACpB,GAEI,MAAMgI,EAAahI,EAAQ,YAAc,KAAK,UAAU,WAClDiI,EAAYjI,EAAQ,WAAa,KAAK,UAAU,KAAK,UACrDwE,EAAYxE,EAAQ,OAC1B,IAAIqK,EAAarK,EAAQ,WACrBqK,EAEFA,EADoB,MAAM,QAAQA,CAAU,GAAKA,EAAW,SAAW,EAC5CA,EAAa7B,EAAM,OAAO,SAAS6B,CAAU,EAAE,QAAO,EAEjFA,EAAaF,GAEf,MAAMG,EAAStK,EAAQ,OAAO,OAAOiK,EAAQ,GAAKM,GAAe/F,EAAWrC,EAAU,EAAE,UACxFmI,EAAO,MAAQ,KAAK,IAAIA,EAAO,MAAO,EAAItC,CAAU,EAAI,EACxDsC,EAAO,OAAS,KAAK,IAAIA,EAAO,OAAQ,EAAItC,CAAU,EAAI,EAC1D,MAAMsB,EAASO,EAAc,OAAO,CAClC,GAAG7J,EAAQ,qBACX,MAAOsK,EAAO,MACd,OAAQA,EAAO,OACf,WAAAtC,EACA,UAAAC,CACN,CAAK,EACKJ,EAAYtH,EAAO,OAAO,UAAU,CAAC+J,EAAO,EAAG,CAACA,EAAO,CAAC,EAC9D,YAAK,UAAU,OAAO,CACpB,UAAA9F,EACA,UAAAqD,EACA,OAAAyB,EACA,WAAAe,CACN,CAAK,EACDf,EAAO,OAAO,cAAa,EACpBA,CACT,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACF,CAEAc,GAAsB,UAAY,CAChC,KAAM,CACJpI,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,kBACR,ECvGA,SAASwI,GAAUC,EAAM,CACvB,IAAIC,EAAQ,GACZ,UAAWjJ,KAAKgJ,EACd,GAAIA,EAAKhJ,CAAC,GAAK,KAAQ,CACrBiJ,EAAQ,GACR,KACF,CAEF,GAAI,CAACA,EAAO,OAAOD,EACnB,MAAME,EAA6B,OAAO,OAAO,IAAI,EACrD,UAAWlJ,KAAKgJ,EAAM,CACpB,MAAM7J,EAAQ6J,EAAKhJ,CAAC,EAChBb,IACF+J,EAAWlJ,CAAC,EAAIb,EAEpB,CACA,OAAO+J,CACT,CACA,SAASC,GAAWC,EAAK,CACvB,IAAIC,EAAS,EACb,QAASrJ,EAAI,EAAGA,EAAIoJ,EAAI,OAAQpJ,IAC1BoJ,EAAIpJ,CAAC,GAAK,KACZqJ,IAEAD,EAAIpJ,EAAIqJ,CAAM,EAAID,EAAIpJ,CAAC,EAG3B,OAAAoJ,EAAI,QAAUC,EACPD,CACT,CC1BA,MAAME,EAAY,MAAMA,EAAU,CAKhC,YAAY7J,EAAU,CAEpB,KAAK,kBAAoB,CAAA,EACzB,KAAK,uBAAyB,CAAA,EAC9B,KAAK,oBAAsB,CAAA,EAC3B,KAAK,OAAS,GACd,KAAK,UAAYA,CACnB,CAKA,KAAKlB,EAAS,CACZA,EAAU,CAAE,GAAG+K,GAAU,eAAgB,GAAG/K,CAAO,EACnD,KAAK,cAAgBA,EAAQ,gBAC7B,KAAK,WAAaA,EAAQ,YAC1B,KAAK,QAAUA,EAAQ,SACvB,KAAK,IAAM,YAAY,IAAG,CAC5B,CAKA,IAAI,SAAU,CACZ,MAAO,CAAC,CAAC,KAAK,QAChB,CAMA,IAAI,QAAQY,EAAO,CACb,KAAK,UAAYA,IACjBA,GACF,KAAK,SAAW,KAAK,UAAU,UAAU,OACvC,IAAM,CACJ,KAAK,OAAS,EAChB,EACA,KAAK,WACL,EACR,EACM,KAAK,oBAAsB,KAAK,UAAU,UAAU,OAClD,IAAM,CACJ,UAAW6J,KAAQ,KAAK,oBAAqB,CAC3C,KAAM,CAAE,QAAAO,EAAS,WAAAC,EAAY,KAAAC,CAAI,EAAKT,EAClCS,IAAS,OACXF,EAAQC,CAAU,EAAIT,GAAUQ,EAAQC,CAAU,CAAC,EAEnDD,EAAQC,CAAU,EAAIL,GAAWI,EAAQC,CAAU,CAAC,CAExD,CACF,EACA,KAAK,UACb,IAEM,KAAK,UAAU,UAAU,OAAO,KAAK,QAAQ,EAC7C,KAAK,UAAU,UAAU,OAAO,KAAK,mBAAmB,EACxD,KAAK,SAAW,EAChB,KAAK,oBAAsB,GAE/B,CAMA,UAAU,CAAE,UAAAzG,GAAa,CACvB,KAAK,IAAM,YAAY,IAAG,EAC1BA,EAAU,YAAY,OAAS,KAAK,UAAU,OAC9C,KAAK,yBAAyBA,EAAU,YAAaA,EAAU,YAAY,MAAM,CACnF,CAEA,YAAa,CACP,CAAC,KAAK,QAAU,CAAC,KAAK,UAC1B,KAAK,IAAG,EACR,KAAK,OAAS,GAChB,CAMA,yBAAyBE,EAAayG,EAAQ,CAC5CzG,EAAY,eAAe,OAASyG,EACpCzG,EAAY,OAASyG,EACrB,UAAWxE,KAASjC,EAAY,oBAC9B,KAAK,yBAAyBiC,EAAOwE,CAAM,CAE/C,CAOA,cAAcH,EAASC,EAAYC,EAAM,CACvC,KAAK,oBAAoB,KAAK,CAC5B,QAAAF,EACA,WAAAC,EACA,KAAAC,CACN,CAAK,CACH,CAMA,YAAYE,EAAUF,EAAM,CAC1B,GAAIE,EAAS,cAAgB,GAAI,CAC/BA,EAAS,YAAc,KAAK,IAC5BA,EAAS,WAAW,KAAK,GAAG,EAC5B,MACF,CACA,MAAMxF,EAAQ,KAAK,kBAAkB,OACrCwF,EAAS,QAAU,CACjB,MAAAxF,EACA,KAAAsF,CACN,EACIE,EAAS,YAAc,KAAK,IAC5BA,EAAS,WAAW,KAAK,GAAG,EAC5BA,EAAS,KAAK,SAAU,KAAK,eAAgB,IAAI,EACjD,KAAK,kBAAkB,KAAKA,CAAQ,CACtC,CAMA,eAAeA,EAAU,CACvB,MAAMC,EAASD,EAAS,QACxB,GAAI,CAACC,EAAQ,OACb,MAAMzF,EAAQyF,EAAO,MACfC,EAAO,KAAK,kBAAkB,OAAS,EAC7C,GAAI1F,IAAU0F,EAAM,CAClB,MAAMC,EAAe,KAAK,kBAAkBD,CAAI,EAChD,KAAK,kBAAkB1F,CAAK,EAAI2F,EAChCA,EAAa,QAAQ,MAAQ3F,CAC/B,CACA,KAAK,kBAAkB,SACvBwF,EAAS,QAAU,KACnBA,EAAS,YAAc,EACzB,CASA,gBAAgBJ,EAASP,EAAMS,EAAMM,EAAW,EAAG,CACjD,KAAK,uBAAuB,KAAK,CAC/B,QAAAR,EACA,KAAAP,EACA,KAAAS,EACA,SAAAM,CACN,CAAK,EACD,KAAK,uBAAuB,KAAK,CAACC,EAAGC,IAAMD,EAAE,SAAWC,EAAE,QAAQ,CACpE,CAKA,KAAM,CACJ,MAAMC,EAAM,YAAY,IAAG,EACrBC,EAAwB,KAAK,uBACnC,UAAWC,KAAaD,EACtB,KAAK,UAAUC,EAAWF,CAAG,EAE/B,IAAIG,EAAa,EACjB,QAASrK,EAAI,EAAGA,EAAI,KAAK,kBAAkB,OAAQA,IAAK,CACtD,MAAM2J,EAAW,KAAK,kBAAkB3J,CAAC,EACzCqK,EAAa,KAAK,cAAcV,EAAUO,EAAKG,CAAU,CAC3D,CACA,KAAK,kBAAkB,OAASA,CAClC,CACA,uBAAuBzG,EAAYsG,EAAK,CACtC,MAAMjH,EAAcW,EAAW,aAAeA,EAAW,kBACnD0G,EAAcrH,GAAa,gBAAgB,QAAU,IACtDA,GAAa,QAAU,KAAOqH,IACjC1G,EAAW,YAAcsG,EACzBtG,EAAW,WAAWsG,CAAG,EAE7B,CACA,cAAcP,EAAUO,EAAKG,EAAY,CACvC,MAAMT,EAASD,EAAS,QACxB,OAAIC,EAAO,OAAS,cAClB,KAAK,uBAAuBD,EAAUO,CAAG,EAEpBA,EAAMP,EAAS,YAAc,KAAK,eACnC,CAACA,EAAS,oBAC9B,KAAK,kBAAkBU,CAAU,EAAIV,EACrCC,EAAO,MAAQS,EACfA,MAEAV,EAAS,OAAM,EACfA,EAAS,QAAU,KACnBA,EAAS,YAAc,GACvBA,EAAS,IAAI,SAAU,KAAK,eAAgB,IAAI,GAE3CU,CACT,CAOA,iBAAiBE,EAAWC,EAAS,CACnC,MAAMC,EAA4B,OAAO,OAAO,IAAI,EACpD,UAAWC,KAAKH,EAAW,CACzB,GAAIG,IAAMF,EAAS,MACfD,EAAUG,CAAC,IAAM,OAAMD,EAAUC,CAAC,EAAIH,EAAUG,CAAC,EACvD,CACA,OAAOD,CACT,CACA,UAAUL,EAAWF,EAAK,CACxB,KAAM,CAAE,QAAAX,EAAS,KAAAP,EAAM,KAAAS,CAAI,EAAKW,EAC1BG,EAAYhB,EAAQP,CAAI,EAC9B,IAAIyB,EAAY,KACZE,EAAY,EAChB,UAAWC,KAAOL,EAAW,CAC3B,MAAMZ,EAAWY,EAAUK,CAAG,EAC9B,GAAIjB,IAAa,KAAM,CACrBgB,IACIA,IAAc,KAAO,CAACF,IACxBA,EAAY,KAAK,iBAAiBF,EAAWK,CAAG,GAElD,QACF,CACA,GAAIjB,EAAS,cAAgB,GAAI,CAC/BA,EAAS,YAAcO,EACvBP,EAAS,WAAWO,CAAG,EACnBO,IAAWA,EAAUG,CAAG,EAAIjB,GAChC,QACF,CAKA,GAJIF,IAAS,cACX,KAAK,uBAAuBE,EAAUO,CAAG,EAGvC,EADmBA,EAAMP,EAAS,YAAc,KAAK,gBAClCA,EAAS,mBAAoB,CASlD,GARKc,IACCE,EAAY,IAAM,KACpBJ,EAAUK,CAAG,EAAI,KACjBD,KAEAF,EAAY,KAAK,iBAAiBF,EAAWK,CAAG,GAGhDnB,IAAS,aAAc,CACzB,MAAMoB,EAAMlB,EACN1G,EAAc4H,EAAI,aAAeA,EAAI,kBACvC5H,IAAaA,EAAY,mBAAqB,GACpD,CACA0G,EAAS,OAAM,EACfA,EAAS,QAAU,KACnBA,EAAS,YAAc,EACzB,MAAWc,IACTA,EAAUG,CAAG,EAAIjB,EAErB,CACIc,IACFlB,EAAQP,CAAI,EAAIyB,EAEpB,CAEA,SAAU,CACR,KAAK,QAAU,GACf,KAAK,kBAAkB,QAASd,GAAa,CAC3CA,EAAS,IAAI,SAAU,KAAK,eAAgB,IAAI,CAClD,CAAC,EACD,KAAK,kBAAkB,OAAS,EAChC,KAAK,uBAAuB,OAAS,EACrC,KAAK,oBAAoB,OAAS,EAClC,KAAK,UAAY,IACnB,CACF,EAEAL,EAAU,UAAY,CACpB,KAAM,CACJ/I,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,KACN,SAAU,CACZ,EAEA+I,EAAU,eAAiB,CAEzB,SAAU,GAEV,gBAAiB,IAEjB,YAAa,GACf,EACA,IAAIwB,GAAWxB,ECxSf,MAAMyB,EAAoB,CACxB,YAAYtL,EAAU,CACpB,KAAK,YAAc,EACnB,KAAK,wBAA0B,CAAA,EAC/B,KAAK,cAAgB,CAAA,EACrB,KAAK,gBAAkB,CAAA,EACvB,KAAK,eAAiB,CAAA,EACtB,KAAK,kBAAoB,CAAA,EACzB,KAAK,UAAYA,CACnB,CACA,OAAQ,CACN,KAAK,YAAc,EACnB,QAASO,EAAI,EAAGA,EAAI,KAAK,gBAAgB,OAAQA,IAC/C,KAAK,cAAc,KAAK,KAAK,gBAAgBA,CAAC,CAAC,EAEjD,QAASA,EAAI,EAAGA,EAAI,KAAK,kBAAkB,OAAQA,IACjD,KAAK,eAAe,KAAK,KAAK,kBAAkBA,CAAC,CAAC,EAEpD,KAAK,gBAAgB,OAAS,EAC9B,KAAK,kBAAkB,OAAS,CAClC,CACA,MAAMzB,EAAS,CACb,KAAK,MAAK,EACV,KAAK,KAAKA,CAAO,CACnB,CACA,KAAK,CACH,KAAAyM,EACA,iBAAAC,EACA,qBAAA3H,EACA,WAAA4H,EACA,OAAA7B,CACJ,EAAK,CACD,MAAM8B,EAAe,KAAK,UAAU,aAAa,aAC3CC,EAA2B,KAAK,YAAc,KAAK,wBAAwB,KAAK,YAAc,CAAC,EAAI,CAEvG,qBAAsB,IAAItM,EAC1B,WAAY,WACZ,OAAQ,IAAIuM,EAClB,EACUC,EAAoB,CACxB,iBAAkBL,GAAoB,KAAK,UAAU,aAAa,iBAClE,WAAYD,GAAQG,EAAa,KACjC,qBAAsB7H,GAAwB8H,EAAyB,qBACvE,WAAYF,GAAcE,EAAyB,WACnD,OAAQ/B,GAAU+B,EAAyB,OAC3C,UAAW,IACjB,EACUG,EAAe,KAAK,cAAc,IAAG,GAAM,KAAK,gBAAe,EACrE,KAAK,gBAAgB,KAAKA,CAAY,EACtC,MAAMC,EAAWD,EAAa,SAC9BC,EAAS,kBAAoBF,EAAkB,iBAC/CE,EAAS,YAAcF,EAAkB,WACzCE,EAAS,sBAAsB,SAASF,EAAkB,oBAAoB,EAC9EE,EAAS,sBAAsB,IAAMF,EAAkB,OAAO,EAC9DE,EAAS,sBAAsB,IAAMF,EAAkB,OAAO,EAC9DG,GACEH,EAAkB,WAClBE,EAAS,iBACT,CACN,EACID,EAAa,OAAM,EACnB,IAAIG,EACA,KAAK,UAAU,YAAY,aAC7BA,EAAY,KAAK,UAAU,YAAY,aAAa,oBAAoBH,EAAc,EAAK,GAE3FG,EAAY,KAAK,eAAe,IAAG,GAAM,IAAIC,GAC7C,KAAK,kBAAkB,KAAKD,CAAS,EACrCA,EAAU,YAAYH,EAAc,CAAC,GAEvCD,EAAkB,UAAYI,EAC9B,KAAK,0BAA4BJ,CACnC,CACA,KAAK/M,EAAS,CACZ,KAAK,KAAKA,CAAO,EACjB,KAAK,wBAAwB,KAAK,aAAa,EAAI,KAAK,yBAC1D,CACA,KAAM,CACJ,KAAK,0BAA4B,KAAK,wBAAwB,EAAE,KAAK,YAAc,CAAC,EAChF,KAAK,UAAU,OAASwD,EAAa,OACvC,KAAK,0BAA0B,UAAU,UAAU,CAAC,EAAE,OAAM,CAEhE,CACA,IAAI,WAAY,CACd,OAAO,KAAK,0BAA0B,SACxC,CACA,IAAI,mBAAoB,CACtB,OAAO,KAAK,yBACd,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,0BAA0B,UAAU,UAAU,CAAC,CAC7D,CACA,iBAAkB,CAUhB,OATuB,IAAIlD,GAAa,CACtC,kBAAmB,CAAE,MAAO,IAAIC,EAAU,KAAM,aAAa,EAC7D,sBAAuB,CAAE,MAAO,IAAIA,EAAU,KAAM,aAAa,EAEjE,iBAAkB,CAAE,MAAO,IAAI,aAAa,CAAC,EAAG,KAAM,WAAW,EACjE,YAAa,CAAE,MAAO,CAAC,EAAG,CAAC,EAAG,KAAM,WAAW,CACrD,EAAO,CACD,SAAU,EAChB,CAAK,CAEH,CACA,SAAU,CACR,KAAK,UAAY,KACjB,KAAK,wBAAwB,OAAS,EACtC,KAAK,cAAc,OAAS,EAC5B,KAAK,gBAAgB,OAAS,EAC9B,KAAK,eAAe,OAAS,EAC7B,KAAK,kBAAkB,OAAS,EAChC,KAAK,0BAA4B,IACnC,CACF,CAEAiM,GAAoB,UAAY,CAC9B,KAAM,CACJxK,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,gBACR,EC9HA,IAAIqL,GAAM,EACV,MAAMC,EAAgB,CACpB,aAAc,CACZ,KAAK,OAAS,CAAA,EAEd,KAAK,QAAU,CACjB,CAEA,MAAO,CACLC,GAAO,OAAO,IAAI,KAAK,QAAS,IAAI,CACtC,CAQA,OAAOC,EAAMC,EAAUC,EAAY,GAAM,CACvC,MAAMC,EAAKN,KACX,IAAIvC,EAAS,EACb,OAAI4C,IACF,KAAK,SAAW,IAChB5C,EAAS,KAAK,SAEhB,KAAK,OAAO,KAAK,CACf,KAAA0C,EACA,SAAAC,EACA,MAAO,YAAY,IAAG,EACtB,OAAA3C,EACA,KAAM,YAAY,IAAG,EACrB,OAAQ,GACR,GAAA6C,CACN,CAAK,EACMA,CACT,CAKA,OAAOA,EAAI,CACT,QAASlM,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IACtC,GAAI,KAAK,OAAOA,CAAC,EAAE,KAAOkM,EAAI,CAC5B,KAAK,OAAO,OAAOlM,EAAG,CAAC,EACvB,MACF,CAEJ,CAKA,SAAU,CACR,MAAMkK,EAAM,YAAY,IAAG,EAC3B,QAASlK,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IAAK,CAC3C,MAAMmM,EAAO,KAAK,OAAOnM,CAAC,EAC1B,GAAIkK,EAAMiC,EAAK,OAASA,EAAK,MAAQA,EAAK,SAAU,CAClD,MAAMC,EAAUlC,EAAMiC,EAAK,MAC3BA,EAAK,KAAKC,CAAO,EACjBD,EAAK,KAAOjC,CACd,CACF,CACF,CAKA,SAAU,CACR4B,GAAO,OAAO,OAAO,KAAK,QAAS,IAAI,EACvC,KAAK,OAAO,OAAS,CACvB,CACF,CAEAD,GAAgB,UAAY,CAC1B,KAAM,CACJtL,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,YACN,SAAU,CACZ,ECjFA,IAAI8L,GAAY,GAChB,SAASC,GAAS7C,EAAM,CACtB,GAAI,CAAA4C,GAGJ,IAAIhF,EAAW,MAAM,eAAe,UAAU,YAAW,EAAG,QAAQ,QAAQ,EAAI,GAAI,CAClF,MAAMkF,EAAO,CACX,iCAAiCC,EAAO,KAAK/C,CAAI;AAAA;AAAA,EAGjD,sCACA,sCACA,sCACA,sCACA,sDACA,qDACN,EACI,WAAW,QAAQ,IAAI,GAAG8C,CAAI,CAChC,MAAW,WAAW,SACpB,WAAW,QAAQ,IAAI,UAAUC,EAAO,MAAM/C,CAAI,2BAA2B,EAE/E4C,GAAY,GACd,CCrBA,MAAMI,CAAY,CAChB,YAAYhN,EAAU,CACpB,KAAK,UAAYA,CACnB,CAKA,KAAKlB,EAAS,CACZ,GAAIA,EAAQ,MAAO,CACjB,IAAIqB,EAAO,KAAK,UAAU,KACtB,KAAK,UAAU,OAASmC,EAAa,QACvCnC,GAAQ,IAAI,KAAK,UAAU,QAAQ,YAAY,IAEjD0M,GAAS1M,CAAI,CACf,CACF,CACF,CAEA6M,EAAY,UAAY,CACtB,KAAM,CACJlM,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,QACN,SAAU,EACZ,EAEAkM,EAAY,eAAiB,CAE3B,MAAO,EACT,ECjCA,MAAMC,EAAsB,MAAMA,EAAoB,CAKpD,YAAYjN,EAAU,CACpB,KAAK,UAAYA,CACnB,CAKA,KAAKlB,EAAS,CACZA,EAAU,CAAE,GAAGmO,GAAoB,eAAgB,GAAGnO,CAAO,EAC7D,KAAK,cAAgBA,EAAQ,yBAC/B,CAKA,IAAI,SAAU,CACZ,OAAAoO,EAAY,SAAU,oFAAoF,EACnG,KAAK,UAAU,GAAG,OAC3B,CAMA,IAAI,QAAQxN,EAAO,CACjBwN,EAAY,SAAU,oFAAoF,EAC1G,KAAK,UAAU,GAAG,QAAUxN,CAC9B,CAMA,eAAeoK,EAASP,EAAM,CAC5B2D,EAAY,SAAU,iGAAiG,EACvH,KAAK,UAAU,GAAG,cAAcpD,EAASP,EAAM,MAAM,CACvD,CAMA,gBAAgBO,EAASP,EAAM,CAC7B2D,EAAY,SAAU,kGAAkG,EACxH,KAAK,UAAU,GAAG,cAAcpD,EAASP,EAAM,OAAO,CACxD,CAMA,cAAc4D,EAAa,CACzBD,EAAY,SAAU,kFAAkF,EACxG,KAAK,UAAU,GAAG,YAAYC,EAAa,YAAY,CACzD,CAKA,KAAM,CACJD,EAAY,SAAU,wEAAwE,EAC9F,KAAK,UAAU,GAAG,IAAG,CACvB,CAEA,SAAU,CACR,KAAK,UAAY,IACnB,CACF,EAKAD,EAAoB,UAAY,CAC9B,KAAM,CACJnM,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,eACN,SAAU,CACZ,EAMAmM,EAAoB,eAAiB,CAEnC,mBAAoB,GAEpB,0BAA2B,IAE3B,sBAAuB,GACzB,EACA,IAAIG,GAAqBH,ECnGzB,MAAMI,EAAmB,MAAMA,CAAiB,CAM9C,IAAI,OAAQ,CACV,OAAO,KAAK,UAAU,IACxB,CAMA,IAAI,YAAa,CACf,OAAO,KAAK,WACd,CACA,IAAI,WAAW3N,EAAO,CACpBwN,EAAY,SAAU,qEAAqE,EAC3F,KAAK,YAAcxN,CACrB,CAMA,IAAI,SAAU,CACZ,OAAO,KAAK,UAAU,GAAG,cAAgB,IAAM,EACjD,CACA,IAAI,QAAQA,EAAO,CACjBwN,EAAY,SAAU,qEAAqE,EAC3F,KAAK,UAAU,GAAG,cAAgBxN,EAAQ,GAAK,GACjD,CAOA,IAAI,eAAgB,CAClB,OAAO,KAAK,MAAM,KAAK,UAAU,GAAG,WAAgB,GAAG,CACzD,CACA,IAAI,cAAc4N,EAAQ,CACxBJ,EAAY,SAAU,qEAAqE,CAC7F,CAMA,IAAI,QAAS,CACX,OAAO,KAAK,UAAU,GAAG,OAC3B,CACA,IAAI,OAAOxN,EAAO,CAChBwN,EAAY,SAAU,qEAAqE,EAC3F,KAAK,UAAU,GAAG,QAAUxN,CAC9B,CAEA,YAAYM,EAAU,CACpB,KAAK,UAAYA,EACjB,KAAK,YAAc,CACrB,CACA,KAAKlB,EAAS,CACRA,EAAQ,kBAAoBuO,EAAiB,eAAe,kBAC9D,KAAK,OAASvO,EAAQ,iBAEpBA,EAAQ,mBAAqBuO,EAAiB,eAAe,mBAC/D,KAAK,QAAUvO,EAAQ,kBAErBA,EAAQ,yBAA2BuO,EAAiB,eAAe,yBACrE,KAAK,cAAgBvO,EAAQ,uBAEjC,CAMA,KAAM,CACJoO,EAAY,SAAU,qEAAqE,EAC3F,KAAK,UAAU,GAAG,IAAG,CACvB,CACA,SAAU,CACR,KAAK,UAAY,IACnB,CACF,EAEAG,EAAiB,UAAY,CAC3B,KAAM,CACJvM,EAAc,YACdA,EAAc,YAClB,EACE,KAAM,WACR,EAKAuM,EAAiB,eAAiB,CAKhC,gBAAiB,GAKjB,kBAAmB,KAKnB,iBAAkB,KAKlB,uBAAwB,GAC1B,EACA,IAAIE,GAAkBF,ECvHtB,MAAMG,GAAgB,MAAMA,EAAc,CAIxC,YAAYC,EAAa,GAAI,CAiB3B,GAfA,KAAK,IAAMtB,GAAI,cAAc,EAK7B,KAAK,cAAgB,CAAA,EACrB,KAAK,QAAU,EACf,KAAK,OAAS,GACd,KAAK,MAAQ,IAAI,aAAa,CAAC,EAE/B,KAAK,sBAAwB,GAC7BsB,EAAa,CAAE,GAAGD,GAAc,eAAgB,GAAGC,CAAU,EAC7D,KAAK,QAAUA,EAAW,QAC1B,KAAK,MAAQA,EAAW,MACxB,KAAK,OAASA,EAAW,OACrB,OAAOA,EAAW,eAAkB,SAAU,CAChD,KAAK,sBAAwB,GAC7B,QAASlN,EAAI,EAAGA,EAAIkN,EAAW,cAAelN,IAC5C,KAAK,cAAc,KACjB,IAAIsI,EAAc,CAChB,MAAO4E,EAAW,MAClB,OAAQA,EAAW,OACnB,WAAYA,EAAW,WACvB,UAAWA,EAAW,SAClC,CAAW,CACX,CAEI,KAAO,CACL,KAAK,cAAgB,CAAC,GAAGA,EAAW,cAAc,IAAKvG,GAAYA,EAAQ,MAAM,CAAC,EAClF,MAAMwG,EAAc,KAAK,aAAa,OACtC,KAAK,OAAOA,EAAY,MAAOA,EAAY,OAAQA,EAAY,WAAW,CAC5E,CACA,KAAK,aAAa,OAAO,GAAG,SAAU,KAAK,eAAgB,IAAI,GAC3DD,EAAW,qBAAuB,KAAK,WACrCA,EAAW,+BAA+BnM,GAAWmM,EAAW,+BAA+B5E,EACjG,KAAK,oBAAsB4E,EAAW,oBAAoB,OAE1D,KAAK,0BAAyB,EAGpC,CACA,IAAI,MAAO,CACT,MAAME,EAAQ,KAAK,MACnB,OAAAA,EAAM,CAAC,EAAI,KAAK,WAChBA,EAAM,CAAC,EAAI,KAAK,YACTA,CACT,CACA,IAAI,OAAQ,CACV,OAAO,KAAK,aAAa,OAAO,KAClC,CACA,IAAI,QAAS,CACX,OAAO,KAAK,aAAa,OAAO,MAClC,CACA,IAAI,YAAa,CACf,OAAO,KAAK,aAAa,OAAO,UAClC,CACA,IAAI,aAAc,CAChB,OAAO,KAAK,aAAa,OAAO,WAClC,CACA,IAAI,YAAa,CACf,OAAO,KAAK,aAAa,OAAO,WAClC,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,cAAc,CAAC,CAC7B,CACA,eAAehP,EAAQ,CACrB,KAAK,OAAOA,EAAO,MAAOA,EAAO,OAAQA,EAAO,YAAa,EAAI,CACnE,CAMA,2BAA4B,CACrB,KAAK,sBACR,KAAK,oBAAsB,IAAIkK,EAAc,CAC3C,MAAO,KAAK,MACZ,OAAQ,KAAK,OACb,WAAY,KAAK,WACjB,OAAQ,uBACR,oBAAqB,GACrB,UAAW,GACX,cAAe,CAEvB,CAAO,EAEL,CACA,OAAON,EAAOO,EAAQhC,EAAa,KAAK,WAAY8G,EAAmB,GAAO,CAC5E,KAAK,UACL,KAAK,cAAc,QAAQ,CAACC,EAAc,IAAM,CAC1CD,GAAoB,IAAM,GAC9BC,EAAa,OAAO,OAAOtF,EAAOO,EAAQhC,CAAU,CACtD,CAAC,EACG,KAAK,qBACP,KAAK,oBAAoB,OAAO,OAAOyB,EAAOO,EAAQhC,CAAU,CAEpE,CACA,SAAU,CACR,KAAK,aAAa,OAAO,IAAI,SAAU,KAAK,eAAgB,IAAI,EAC5D,KAAK,uBACP,KAAK,cAAc,QAASI,GAAY,CACtCA,EAAQ,QAAO,CACjB,CAAC,EAEC,KAAK,sBACP,KAAK,oBAAoB,QAAO,EAChC,OAAO,KAAK,oBAEhB,CACF,EAEAsG,GAAc,eAAiB,CAE7B,MAAO,EAEP,OAAQ,EAER,WAAY,EAEZ,cAAe,EAEf,QAAS,GAET,MAAO,GAEP,UAAW,GAGX,OAAQ,EACV,EACA,IAAIM,EAAeN,GCxInB,MAAMO,EAA8B,IAAI,IACxCC,GAAuB,SAASD,CAAW,EAC3C,SAASE,GAAiBlG,EAAQjJ,EAAS,CACzC,GAAI,CAACiP,EAAY,IAAIhG,CAAM,EAAG,CAC5B,MAAMb,EAAU,IAAI5F,EAAQ,CAC1B,OAAQ,IAAI4M,EAAa,CACvB,SAAUnG,EACV,GAAGjJ,CACX,CAAO,CACP,CAAK,EACKqP,EAAY,IAAM,CAClBJ,EAAY,IAAIhG,CAAM,IAAMb,GAC9B6G,EAAY,OAAOhG,CAAM,CAE7B,EACAb,EAAQ,KAAK,UAAWiH,CAAS,EACjCjH,EAAQ,OAAO,KAAK,UAAWiH,CAAS,EACxCJ,EAAY,IAAIhG,EAAQb,CAAO,CACjC,CACA,OAAO6G,EAAY,IAAIhG,CAAM,CAC/B,CCjBA,MAAMqG,EAAc,MAAMA,EAAY,CAMpC,IAAI,aAAc,CAChB,OAAO,KAAK,QAAQ,OAAO,WAC7B,CACA,IAAI,YAAY1O,EAAO,CACrB,KAAK,QAAQ,OAAO,YAAcA,CACpC,CAEA,IAAI,YAAa,CACf,OAAO,KAAK,QAAQ,OAAO,WAC7B,CACA,IAAI,WAAWA,EAAO,CACpB,KAAK,QAAQ,OAAO,OAClB,KAAK,QAAQ,OAAO,MACpB,KAAK,QAAQ,OAAO,OACpBA,CACN,CACE,CAKA,KAAKZ,EAAS,CACZA,EAAU,CACR,GAAGsP,GAAY,eACf,GAAGtP,CACT,EACQA,EAAQ,OACVoO,EAAYmB,GAAQ,uDAAuD,EAC3EvP,EAAQ,OAASA,EAAQ,MAE3B,KAAK,OAAS,IAAIkK,EAAU,EAAG,EAAGlK,EAAQ,MAAOA,EAAQ,MAAM,EAC/D,KAAK,OAASA,EAAQ,QAAU8I,EAAW,IAAG,EAAG,aAAY,EAC7D,KAAK,UAAY,CAAC,CAAC9I,EAAQ,UAC3B,KAAK,QAAUmP,GAAiB,KAAK,OAAQnP,CAAO,EACpD,KAAK,aAAe,IAAIgP,EAAa,CACnC,cAAe,CAAC,KAAK,OAAO,EAC5B,MAAO,CAAC,CAAChP,EAAQ,MACjB,OAAQ,EACd,CAAK,EACD,KAAK,QAAQ,OAAO,YAAcA,EAAQ,gBAAkB,EAC5D,KAAK,WAAaA,EAAQ,UAC5B,CAOA,OAAOwP,EAAoBC,EAAqBzH,EAAY,CAC1D,KAAK,QAAQ,OAAO,OAAOwH,EAAoBC,EAAqBzH,CAAU,EAC9E,KAAK,OAAO,MAAQ,KAAK,QAAQ,MAAM,MACvC,KAAK,OAAO,OAAS,KAAK,QAAQ,MAAM,MAC1C,CASA,QAAQhI,EAAU,GAAO,EACJ,OAAOA,GAAY,UAAYA,EAAYA,GAAS,aACrD,KAAK,OAAO,YAC5B,KAAK,OAAO,WAAW,YAAY,KAAK,MAAM,EAEhD,KAAK,QAAQ,QAAO,CACtB,CACF,EAEAsP,EAAY,UAAY,CACtB,KAAM,CACJtN,EAAc,YACdA,EAAc,aACdA,EAAc,YAClB,EACE,KAAM,OACN,SAAU,CACZ,EAEAsN,EAAY,eAAiB,CAK3B,MAAO,IAKP,OAAQ,IAKR,YAAa,GAKb,UAAW,EACb,EACA,IAAII,GAAaJ,EC9FZ,MAACK,GAAgB,CACpBlH,GACA+D,GACA0B,EACAwB,GACA9H,GACA2E,GACAkC,GACArE,GACAR,GACAgG,GACAtB,GACAhB,EACF,EACMuC,GAAoB,CACxBzK,GACAnD,GACA+C,GACAJ,GACAnC,GACAqB,GACAL,GACAc,EACF,EC5CA,SAASuL,GAAoBC,EAAIC,EAAGC,EAAGxG,EAAOO,EAAQkG,EAAO,CAC3D,MAAMC,EAAOD,EAAQ,EAAI,GACzB,OAAAH,EAAG,SAAQ,EACXA,EAAG,EAAI,EAAItG,EAAQ,EACnBsG,EAAG,EAAII,GAAQ,EAAInG,EAAS,GAC5B+F,EAAG,GAAK,GAAKC,EAAID,EAAG,EACpBA,EAAG,GAAK,CAACI,EAAOF,EAAIF,EAAG,EAChBA,CACT,CCRA,SAASK,GAAoBxD,EAAc,CACzC,MAAMxB,EAAWwB,EAAa,aAAa,OAAO,SAClD,OAAO,WAAW,mBAAqBxB,aAAoB,mBAAqB,SAAS,KAAK,SAASA,CAAQ,CACjH,CCSA,MAAMiF,EAAmB,CACvB,YAAYnP,EAAU,CAEpB,KAAK,aAAe,IAAIgJ,EAExB,KAAK,SAAW,IAAIA,EAEpB,KAAK,SAAW,EAEhB,KAAK,MAAQ,EAKb,KAAK,qBAAuB,IAAIoG,GAAa,sBAAsB,EAEnE,KAAK,iBAAmB,IAAI/P,EAE5B,KAAK,kBAAoB,CAAC,EAAG,EAAG,EAAG,CAAC,EAKpC,KAAK,iCAAmD,IAAI,IAE5D,KAAK,qBAAuC,OAAO,OAAO,IAAI,EAM9D,KAAK,mBAAqB,CAAA,EAC1B,KAAK,UAAYW,EACjBA,EAAS,GAAG,cAAc,KAAM,uBAAwB,MAAM,CAChE,CAEA,kBAAmB,CACjB,KAAK,QAAQ,iBAAiB,KAAK,YAAY,CACjD,CAYA,YAAY,CACV,OAAAoI,EACA,MAAAiH,EACA,WAAAlG,EACA,MAAAmG,EACA,SAAAC,EACA,MAAAC,CACJ,EAAK,CACD,KAAK,mBAAmB,OAAS,EACjC,KAAK,KACHpH,EACAiH,EACAlG,EACAmG,EACAC,GAAY,EACZC,GAAS,CACf,EACI,KAAK,aAAa,SAAS,KAAK,QAAQ,EACxC,KAAK,iBAAmB,KAAK,aAC7B,KAAK,kBAAoBN,GAAoB,KAAK,gBAAgB,EAClE,KAAK,QAAQ,YAAY,KAAK,gBAAgB,CAChD,CACA,YAAa,CACX,KAAK,QAAQ,aAAa,KAAK,gBAAgB,CACjD,CA0BA,KAAKO,EAAeJ,EAAQ,GAAMlG,EAAYmG,EAAOC,EAAW,EAAGC,EAAQ,EAAG,CAC5E,MAAM9D,EAAe,KAAK,gBAAgB+D,CAAa,EACjDC,EAAY,KAAK,eAAiBhE,EACxC,KAAK,aAAeA,EACpB,KAAK,cAAgB+D,EACrB,MAAME,EAAkB,KAAK,mBAAmBjE,CAAY,GACxDA,EAAa,aAAeiE,EAAgB,OAASjE,EAAa,cAAgBiE,EAAgB,UACpG,KAAK,QAAQ,sBAAsBjE,CAAY,EAC/CiE,EAAgB,MAAQjE,EAAa,WACrCiE,EAAgB,OAASjE,EAAa,aAExC,MAAM/M,EAAS+M,EAAa,aACtBkE,EAAW,KAAK,SAChBC,EAAkBlR,EAAO,iBAAmB,EAIlD,IAHK6Q,EAAQ,KAAOA,IAClBA,GAAS,GAEPA,EAAQ,GAAKA,GAASK,EACxB,MAAM,IAAI,MAAM,8BAA8BL,CAAK,sCAAsCK,CAAe,IAAI,EAE9G,KAAK,SAAWN,EAAW,EAC3B,KAAK,MAAQC,EAAQ,EACrB,MAAMM,EAAa,KAAK,IAAInR,EAAO,YAAc4Q,EAAU,CAAC,EACtDQ,EAAc,KAAK,IAAIpR,EAAO,aAAe4Q,EAAU,CAAC,EAI9D,GAHI,CAACD,GAASG,aAAyBnO,IACrCgO,EAAQG,EAAc,OAEpBH,EAAO,CACT,MAAMxI,EAAanI,EAAO,YACpBqR,EAAQ,GAAK,KAAK,IAAIT,EAAW,EAAG,CAAC,EACrCU,GAAQX,EAAM,EAAIxI,EAAa,GAAM,EACrCoJ,GAAQZ,EAAM,EAAIxI,EAAa,GAAM,EACrCqJ,GAAQb,EAAM,MAAQxI,EAAa,GAAM,EACzCsJ,GAAQd,EAAM,OAASxI,EAAa,GAAM,EAChD,IAAIgI,EAAI,KAAK,MAAMmB,GAAQD,CAAK,EAC5BjB,EAAI,KAAK,MAAMmB,GAAQF,CAAK,EAC5BK,EAAI,KAAK,KAAKF,GAAQH,CAAK,EAC3BM,EAAI,KAAK,KAAKF,GAAQJ,CAAK,EAC/BlB,EAAI,KAAK,IAAI,KAAK,IAAIA,EAAG,CAAC,EAAGgB,EAAa,CAAC,EAC3Cf,EAAI,KAAK,IAAI,KAAK,IAAIA,EAAG,CAAC,EAAGgB,EAAc,CAAC,EAC5CM,EAAI,KAAK,IAAI,KAAK,IAAIA,EAAG,CAAC,EAAGP,EAAahB,CAAC,EAC3CwB,EAAI,KAAK,IAAI,KAAK,IAAIA,EAAG,CAAC,EAAGP,EAAchB,CAAC,EAC5Ca,EAAS,EAAId,EACbc,EAAS,EAAIb,EACba,EAAS,MAAQS,EACjBT,EAAS,OAASU,CACpB,MACEV,EAAS,EAAI,EACbA,EAAS,EAAI,EACbA,EAAS,MAAQE,EACjBF,EAAS,OAASG,EAEpB,OAAAnB,GACE,KAAK,iBACL,EACA,EACAgB,EAAS,MAAQjR,EAAO,WACxBiR,EAAS,OAASjR,EAAO,WACzB,CAAC+M,EAAa,MACpB,EACI,KAAK,QAAQ,gBAAgBA,EAAc2D,EAAOlG,EAAYyG,EAAUL,EAAUC,CAAK,EACnFE,GACF,KAAK,qBAAqB,KAAKhE,CAAY,EAEtCA,CACT,CACA,MAAMtD,EAAQiH,EAAQjM,EAAM,IAAK+F,EAAYoG,EAAW,KAAK,SAAUC,EAAQ,KAAK,MAAO,CACpFH,IACDjH,IACFA,EAAS,KAAK,gBAAgBA,CAAM,GAEtC,KAAK,QAAQ,MACXA,GAAU,KAAK,aACfiH,EACAlG,EACA,KAAK,SACLoG,EACAC,CACN,EACE,CACA,eAAgB,CACd,KAAK,qBAAuC,OAAO,OAAO,IAAI,CAChE,CAWA,KAAKC,EAAeJ,EAAQjM,EAAM,IAAK+F,EAAYmG,EAAOC,EAAW,EAAGC,EAAQ,EAAG,CACjF,MAAM9D,EAAe,KAAK,KAAK+D,EAAeJ,EAAOlG,EAAYmG,EAAOC,EAAUC,CAAK,EACvF,YAAK,mBAAmB,KAAK,CAC3B,aAAA9D,EACA,MAAA4D,EACA,SAAAC,EACA,MAAAC,CACN,CAAK,EACM9D,CACT,CAEA,KAAM,CACJ,KAAK,mBAAmB,IAAG,EAC3B,MAAM6E,EAA0B,KAAK,mBAAmB,KAAK,mBAAmB,OAAS,CAAC,EAC1F,KAAK,KACHA,EAAwB,aACxB,GACA,KACAA,EAAwB,MACxBA,EAAwB,SACxBA,EAAwB,KAC9B,CACE,CAQA,gBAAgBd,EAAe,CAC7B,OAAIA,EAAc,YAChBA,EAAgBA,EAAc,QAEzB,KAAK,iCAAiC,IAAIA,CAAa,GAAK,KAAK,kBAAkBA,CAAa,CACzG,CAwCA,cAAce,EAA4BC,EAAoBC,EAAWnF,EAAMoF,EAAY,CACrFD,EAAU,EAAI,IAChBnF,EAAK,OAASmF,EAAU,EACxBC,EAAW,GAAKD,EAAU,EAC1BA,EAAU,EAAI,GAEZA,EAAU,EAAI,IAChBnF,EAAK,QAAUmF,EAAU,EACzBC,EAAW,GAAKD,EAAU,EAC1BA,EAAU,EAAI,GAEhB,KAAM,CAAE,WAAAZ,EAAY,YAAAC,CAAW,EAAKS,EACpC,OAAAjF,EAAK,MAAQ,KAAK,IAAIA,EAAK,MAAOuE,EAAaY,EAAU,CAAC,EAC1DnF,EAAK,OAAS,KAAK,IAAIA,EAAK,OAAQwE,EAAcW,EAAU,CAAC,EACtD,KAAK,QAAQ,cAClBF,EACAC,EACAC,EACAnF,EACAoF,CACN,CACE,CAKA,oBAAqB,CACd,KAAK,aAAa,UACrB,KAAK,aAAa,QAAU,GAC5B,KAAK,QAAQ,gBAAgB,KAAK,aAAc,GAAO,KAAM,KAAK,SAAU,EAAG,KAAK,KAAK,EAE7F,CAEA,SAAU,CACR,KAAK,UAAY,KACjB,KAAK,iCAAiC,QAAQ,CAACjF,EAAcP,IAAQ,CAC/DO,IAAiBP,GACnBO,EAAa,QAAO,CAExB,CAAC,EACD,KAAK,iCAAiC,MAAK,EAC3C,KAAK,qBAAuC,OAAO,OAAO,IAAI,CAChE,CACA,kBAAkB+D,EAAe,CAC/B,IAAI/D,EAAe,KACnB,OAAIwC,EAAa,KAAKuB,CAAa,IACjCA,EAAgBxB,GAAiBwB,CAAa,EAAE,QAE9CA,aAAyB3B,EAC3BpC,EAAe+D,EACNA,aAAyB5G,IAClC6C,EAAe,IAAIoC,EAAa,CAC9B,cAAe,CAAC2B,CAAa,CACrC,CAAO,EACGA,EAAc,kBAAkBvB,IAClCxC,EAAa,OAAS,IAExB+D,EAAc,KAAK,UAAW,IAAM,CAClC/D,EAAa,QAAO,EACpB,KAAK,iCAAiC,OAAO+D,CAAa,EAC1D,MAAME,EAAkB,KAAK,qBAAqBjE,EAAa,GAAG,EAC9DiE,IACF,KAAK,qBAAqBjE,EAAa,GAAG,EAAI,KAC9C,KAAK,QAAQ,uBAAuBiE,CAAe,EAEvD,CAAC,GAEH,KAAK,iCAAiC,IAAIF,EAAe/D,CAAY,EAC9DA,CACT,CACA,mBAAmBA,EAAc,CAC/B,OAAO,KAAK,qBAAqBA,EAAa,GAAG,IAAM,KAAK,qBAAqBA,EAAa,GAAG,EAAI,KAAK,QAAQ,oBAAoBA,CAAY,EACpJ,CACA,YAAa,CACX,KAAK,aAAe,KACpB,KAAK,cAAgB,IACvB,CACF","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]}