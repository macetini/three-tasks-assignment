{"version":3,"file":"webworkerAll-wQajjBwy.js","sources":["../../node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs","../../node_modules/pixi.js/lib/filters/FilterPipe.mjs","../../node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","../../node_modules/pixi.js/lib/filters/FilterSystem.mjs","../../node_modules/pixi.js/lib/filters/init.mjs"],"sourcesContent":["var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './passthrough.frag.mjs';\nimport source from './passthrough.wgsl.mjs';\n\n\"use strict\";\nclass PassthroughFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: { source, entryPoint: \"mainVertex\" },\n      fragment: { source, entryPoint: \"mainFragment\" },\n      name: \"passthrough-filter\"\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"passthrough-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram\n    });\n  }\n}\n\nexport { PassthroughFilter };\n//# sourceMappingURL=PassthroughFilter.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import '../../../maths/index.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempProjectionMatrix = new Matrix();\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const actualMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    if (renderGroup?.isCachedAsTexture) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);\n    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);\n    } else {\n      bounds.matrix = renderable.worldTransform;\n    }\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = actualMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { PassthroughFilter } from './defaults/passthrough/PassthroughFilter.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n    /** The first enabled filter index in the current filter list. */\n    this.firstEnabledIndex = -1;\n    /** The last enabled filter index in the current filter list. */\n    this.lastEnabledIndex = -1;\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();\n    this._setupBindGroupsAndRender(filterToApply, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.orig.width,\n      1 / sprite.texture.orig.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this._passthroughFilter?.destroy(true);\n    this._passthroughFilter = null;\n  }\n  _getPassthroughFilter() {\n    this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());\n    return this._passthroughFilter;\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture) output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    const firstEnabled = filterData.firstEnabledIndex;\n    const lastEnabled = filterData.lastEnabledIndex;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (firstEnabled === lastEnabled) {\n      filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      for (let i = firstEnabled; i < lastEnabled; i++) {\n        const filter = filters[i];\n        if (!filter.enabled) continue;\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    let firstEnabledIndex = -1;\n    let lastEnabledIndex = -1;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (!filter.enabled) continue;\n      if (firstEnabledIndex === -1) firstEnabledIndex = i;\n      lastEnabledIndex = i;\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = true;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n    filterData.firstEnabledIndex = firstEnabledIndex;\n    filterData.lastEnabledIndex = lastEnabledIndex;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 0) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["vertex","fragment","source","PassthroughFilter","Filter","gpuProgram","GpuProgram","glProgram","GlProgram","FilterPipe","renderer","filterEffect","container","instructionSet","_filterEffect","_container","instruction","ExtensionType","tempProjectionMatrix","Matrix","getGlobalRenderableBounds","renderables","bounds","actualMatrix","i","renderable","renderGroup","quadGeometry","Geometry","FilterData","Bounds","FilterSystem","UniformGroup","BindGroup","filters","filterData","colorTextureSource","rootResolution","rootAntialias","filter","previousFilterData","globalResolution","offsetX","offsetY","texture","TexturePool","Texture","outputTexture","lastRenderSurface","previousBounds","backgroundResolution","backTexture","x","y","width","height","input","output","clear","isFinalTarget","resolution","offset","filterToApply","outputMatrix","sprite","data","mappedMatrix","worldTransform","batchUniforms","RendererType","renderTarget","sourceWidth","sourceHeight","globalFrame","uniforms","outputFrame","inputSize","inputPixel","inputClamp","rootTexture","currentIndex","lastIndex","prevFilterData","filterFrameTransform","inputTexture","firstEnabled","lastEnabled","flip","tempTexture","flop","t","viewPort","paddingMultiplier","padding","antialias","blendRequired","enabled","clipToViewport","firstEnabledIndex","lastEnabledIndex","warn","index","extensions"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}